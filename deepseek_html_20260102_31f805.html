<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Finanças Pessoais | Controle Financeiro</title>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <style>
        
        /* Reset e configurações globais */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }

        :root {
            --primary-color: #4361ee;
            --secondary-color: #3a0ca3;
            --success-color: #4cc9f0;
            --danger-color: #f72585;
            --warning-color: #f8961e;
            --light-color: #f8f9fa;
            --dark-color: #212529;
            --gray-color: #6c757d;
            --border-radius: 10px;
            --box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            --transition: all 0.3s ease;
        }

        .dark-mode {
            --primary-color: #4895ef;
            --secondary-color: #560bad;
            --success-color: #4cc9f0;
            --danger-color: #f72585;
            --warning-color: #f8961e;
            --light-color: #121212;
            --dark-color: #e9ecef;
            --gray-color: #adb5bd;
            --box-shadow: 0 4px 6px rgba(0, 0, 0, 0.3);
        }

        body {
            background-color: var(--light-color);
            color: var(--dark-color);
            transition: var(--transition);
            line-height: 1.6;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
        }

        /* Container principal */
        .container {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        /* Sidebar */
        .sidebar {
            width: 250px;
            background-color: var(--primary-color);
            color: white;
            padding: 20px;
            display: flex;
            flex-direction: column;
            transition: var(--transition);
            z-index: 100;
        }

        .sidebar-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 30px;
        }

        .logo {
            font-size: 1.5rem;
            font-weight: 700;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .menu-toggle {
            display: none;
            background: none;
            border: none;
            color: white;
            font-size: 1.2rem;
            cursor: pointer;
        }

        .sidebar-nav {
            flex: 1;
        }

        .nav-list {
            list-style: none;
        }

        .nav-item {
            margin-bottom: 10px;
        }

        .nav-link {
            display: flex;
            align-items: center;
            gap: 10px;
            color: white;
            text-decoration: none;
            padding: 12px 15px;
            border-radius: var(--border-radius);
            transition: var(--transition);
        }

        .nav-link:hover, .nav-link.active {
            background-color: rgba(255, 255, 255, 0.1);
        }

        .sidebar-footer {
            padding-top: 20px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .theme-toggle {
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: rgba(255, 255, 255, 0.1);
            border: none;
            color: white;
            padding: 10px 15px;
            border-radius: var(--border-radius);
            cursor: pointer;
            width: 100%;
        }

        /* Conteúdo principal */
        .main-content {
            flex: 1;
            padding: 20px;
            overflow-y: auto;
        }

        .header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            flex-wrap: wrap;
            gap: 15px;
        }

        .page-title {
            font-size: 1.8rem;
            font-weight: 700;
        }

        .header-actions {
            display: flex;
            gap: 10px;
        }

        .btn {
            padding: 10px 20px;
            border: none;
            border-radius: var(--border-radius);
            font-weight: 600;
            cursor: pointer;
            transition: var(--transition);
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .btn-primary {
            background-color: var(--primary-color);
            color: white;
        }

        .btn-primary:hover {
            background-color: var(--secondary-color);
        }

        .btn-success {
            background-color: var(--success-color);
            color: white;
        }

        .btn-danger {
            background-color: var(--danger-color);
            color: white;
        }

        .btn-warning {
            background-color: var(--warning-color);
            color: white;
        }

        .btn-outline {
            background-color: transparent;
            border: 2px solid var(--primary-color);
            color: var(--primary-color);
        }

        .btn-outline:hover {
            background-color: var(--primary-color);
            color: white;
        }

        /* Cards do Dashboard */
        .dashboard-cards {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .card {
            background-color: white;
            border-radius: var(--border-radius);
            padding: 20px;
            box-shadow: var(--box-shadow);
            transition: var(--transition);
            cursor: move;
        }

        .dark-mode .card {
            background-color: #1e1e1e;
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .card-title {
            font-size: 0.9rem;
            color: var(--gray-color);
            font-weight: 600;
            text-transform: uppercase;
        }

        .card-icon {
            font-size: 1.5rem;
            color: var(--primary-color);
        }

        .card-value {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: 10px;
        }

        .card-positive {
            color: var(--success-color);
        }

        .card-negative {
            color: var(--danger-color);
        }

        /* Gráficos */
        .charts-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(350px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .chart-card {
            background-color: white;
            border-radius: var(--border-radius);
            padding: 20px;
            box-shadow: var(--box-shadow);
        }

        .dark-mode .chart-card {
            background-color: #1e1e1e;
        }

        .chart-title {
            font-size: 1.2rem;
            font-weight: 600;
            margin-bottom: 15px;
            text-align: center;
        }

        .chart-wrapper {
            position: relative;
            height: 300px;
            width: 100%;
        }

        /* Tabela de Transações */
        .transactions-container {
            background-color: white;
            border-radius: var(--border-radius);
            box-shadow: var(--box-shadow);
            overflow: hidden;
            margin-bottom: 30px;
        }

        .dark-mode .transactions-container {
            background-color: #1e1e1e;
        }

        .table-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 20px;
            border-bottom: 1px solid #eee;
        }

        .dark-mode .table-header {
            border-bottom: 1px solid #333;
        }

        .filters {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }

        .filter-select {
            padding: 8px 15px;
            border-radius: var(--border-radius);
            border: 1px solid #ddd;
            background-color: var(--light-color);
            color: var(--dark-color);
        }

        .dark-mode .filter-select {
            border: 1px solid #555;
            background-color: #2d2d2d;
            color: var(--dark-color);
        }

        .table-container {
            overflow-x: auto;
        }

        .transactions-table {
            width: 100%;
            border-collapse: collapse;
        }

        .transactions-table th {
            background-color: #f8f9fa;
            padding: 15px;
            text-align: left;
            font-weight: 600;
            cursor: pointer;
            user-select: none;
            border-bottom: 1px solid #eee;
        }

        .dark-mode .transactions-table th {
            background-color: #2d2d2d;
            border-bottom: 1px solid #333;
        }

        .transactions-table td {
            padding: 15px;
            border-bottom: 1px solid #eee;
        }

        .dark-mode .transactions-table td {
            border-bottom: 1px solid #333;
        }

        .transactions-table tr:hover {
            background-color: #f8f9fa;
        }

        .dark-mode .transactions-table tr:hover {
            background-color: #2d2d2d;
        }

        .transactions-table .income {
            color: var(--success-color);
            font-weight: 600;
        }

        .transactions-table .expense {
            color: var(--danger-color);
            font-weight: 600;
        }

        .action-buttons {
            display: flex;
            gap: 5px;
        }

        .btn-icon {
            background: none;
            border: none;
            cursor: pointer;
            font-size: 1rem;
            padding: 5px;
            border-radius: 5px;
            transition: var(--transition);
        }

        .btn-edit {
            color: var(--primary-color);
        }

        .btn-delete {
            color: var(--danger-color);
        }

        /* Formulário */
        .form-container {
            max-width: 800px;
            margin: 0 auto;
            background-color: white;
            border-radius: var(--border-radius);
            padding: 30px;
            box-shadow: var(--box-shadow);
        }

        .dark-mode .form-container {
            background-color: #1e1e1e;
        }

        .form-title {
            font-size: 1.5rem;
            margin-bottom: 20px;
            font-weight: 700;
        }

        .form-row {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .form-group {
            display: flex;
            flex-direction: column;
        }

        .form-group label {
            margin-bottom: 8px;
            font-weight: 600;
        }

        .form-group input, .form-group select, .form-group textarea {
            padding: 12px 15px;
            border-radius: var(--border-radius);
            border: 1px solid #ddd;
            background-color: var(--light-color);
            color: var(--dark-color);
            transition: var(--transition);
        }

        .dark-mode .form-group input, 
        .dark-mode .form-group select, 
        .dark-mode .form-group textarea {
            border: 1px solid #555;
            background-color: #2d2d2d;
            color: var(--dark-color);
        }

        .form-group input:focus, .form-group select:focus, .form-group textarea:focus {
            outline: none;
            border-color: var(--primary-color);
        }

        .form-actions {
            display: flex;
            justify-content: flex-end;
            gap: 15px;
            margin-top: 30px;
        }

        .alert {
            padding: 15px;
            border-radius: var(--border-radius);
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .alert-warning {
            background-color: rgba(248, 150, 30, 0.1);
            border-left: 4px solid var(--warning-color);
        }

        .alert-danger {
            background-color: rgba(247, 37, 133, 0.1);
            border-left: 4px solid var(--danger-color);
        }

        /* Modal */
        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.5);
            z-index: 1000;
            justify-content: center;
            align-items: center;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background-color: white;
            border-radius: var(--border-radius);
            padding: 30px;
            max-width: 500px;
            width: 90%;
            box-shadow: var(--box-shadow);
        }

        .dark-mode .modal-content {
            background-color: #1e1e1e;
        }

        .modal-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
        }

        .modal-title {
            font-size: 1.5rem;
            font-weight: 700;
        }

        .modal-close {
            background: none;
            border: none;
            font-size: 1.5rem;
            cursor: pointer;
            color: var(--gray-color);
        }

        .modal-body {
            margin-bottom: 30px;
        }

        .modal-footer {
            display: flex;
            justify-content: flex-end;
            gap: 10px;
        }

        /* Import/Export */
        .import-export-container {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 30px;
        }

        .import-export-card {
            background-color: white;
            border-radius: var(--border-radius);
            padding: 30px;
            box-shadow: var(--box-shadow);
            display: flex;
            flex-direction: column;
        }

        .dark-mode .import-export-card {
            background-color: #1e1e1e;
        }

        .import-export-card h3 {
            margin-bottom: 20px;
            font-size: 1.3rem;
        }

        .file-input {
            margin-bottom: 20px;
            padding: 10px;
            border: 2px dashed #ddd;
            border-radius: var(--border-radius);
            text-align: center;
            cursor: pointer;
        }

        .dark-mode .file-input {
            border: 2px dashed #555;
        }

        .file-input:hover {
            border-color: var(--primary-color);
        }

        /* Responsividade */
        @media (max-width: 992px) {
            .sidebar {
                position: fixed;
                left: -250px;
                height: 100%;
            }
            
            .sidebar.active {
                left: 0;
            }
            
            .menu-toggle {
                display: block;
            }
            
            .charts-container {
                grid-template-columns: 1fr;
            }
        }

        @media (max-width: 768px) {
            .header {
                flex-direction: column;
                align-items: flex-start;
            }
            
            .header-actions {
                width: 100%;
                justify-content: flex-end;
            }
            
            .dashboard-cards {
                grid-template-columns: 1fr;
            }
            
            .form-row {
                grid-template-columns: 1fr;
            }
            
            .import-export-container {
                grid-template-columns: 1fr;
            }
            
            .filters {
                width: 100%;
                justify-content: flex-start;
            }
            
            .filter-select {
                width: 100%;
            }
        }

        
    </style>
</head>
<body>
    <div class="container">
        <!-- Sidebar -->
        <aside class="sidebar">
            <div class="sidebar-header">
                <div class="logo">
                    <i class="fas fa-chart-line"></i>
                    Finanças Pessoais
                </div>
                <button class="menu-toggle" id="menuToggle">
                    <i class="fas fa-times"></i>
                </button>
            </div>
            
            <nav class="sidebar-nav">
                <ul class="nav-list">
                    <li class="nav-item">
                        <a href="#dashboard" class="nav-link active" data-page="dashboard">
                            <i class="fas fa-tachometer-alt"></i>
                            Dashboard
                        </a>
                    </li>
                    <li class="nav-item">
                        <a href="#transactions" class="nav-link" data-page="transactions">
                            <i class="fas fa-exchange-alt"></i>
                            Transações
                        </a>
                    </li>
                    <li class="nav-item">
                        <a href="#add-transaction" class="nav-link" data-page="add-transaction">
                            <i class="fas fa-plus-circle"></i>
                            Nova Transação
                        </a>
                    </li>
                    <li class="nav-item">
                        <a href="#import-export" class="nav-link" data-page="import-export">
                            <i class="fas fa-file-import"></i>
                            Importar/Exportar
                        </a>
                    </li>
                    <li class="nav-item">
                        <a href="#limits" class="nav-link" data-page="limits">
                            <i class="fas fa-exclamation-triangle"></i>
                            Alertas e Limites
                        </a>
                    </li>
                </ul>
            </nav>
            
            <div class="sidebar-footer">
                <button class="theme-toggle" id="themeToggle">
                    <span>Modo Escuro</span>
                    <i class="fas fa-moon"></i>
                </button>
            </div>
        </aside>
        
        <!-- Conteúdo Principal -->
        <main class="main-content">
            <!-- Header -->
            <div class="header">
                <h1 class="page-title" id="pageTitle">Dashboard</h1>
                <div class="header-actions">
                    <button class="btn btn-primary" id="backupBtn">
                        <i class="fas fa-database"></i> Backup
                    </button>
                    <button class="btn btn-outline" id="restoreBtn">
                        <i class="fas fa-undo"></i> Restaurar
                    </button>
                </div>
            </div>
            
            <!-- Página: Dashboard -->
            <section id="dashboard" class="page active">
                <div class="dashboard-cards" id="dashboardCards">
                    <div class="card" draggable="true">
                        <div class="card-header">
                            <h3 class="card-title">Total de Receitas</h3>
                            <i class="fas fa-arrow-up card-icon"></i>
                        </div>
                        <div class="card-value card-positive" id="totalIncome">R$ 0,00</div>
                        <p>Último mês: <span id="lastMonthIncome">R$ 0,00</span></p>
                    </div>
                    
                    <div class="card" draggable="true">
                        <div class="card-header">
                            <h3 class="card-title">Total de Despesas</h3>
                            <i class="fas fa-arrow-down card-icon"></i>
                        </div>
                        <div class="card-value card-negative" id="totalExpenses">R$ 0,00</div>
                        <p>Último mês: <span id="lastMonthExpenses">R$ 0,00</span></p>
                    </div>
                    
                    <div class="card" draggable="true">
                        <div class="card-header">
                            <h3 class="card-title">Saldo Atual</h3>
                            <i class="fas fa-wallet card-icon"></i>
                        </div>
                        <div class="card-value" id="currentBalance">R$ 0,00</div>
                        <p>Disponível para gastar</p>
                    </div>
                    
                    <div class="card" draggable="true">
                        <div class="card-header">
                            <h3 class="card-title">Total Investido</h3>
                            <i class="fas fa-chart-line card-icon"></i>
                        </div>
                        <div class="card-value card-positive" id="totalInvested">R$ 0,00</div>
                        <p>Retorno: <span id="investmentReturn">0%</span></p>
                    </div>
                </div>
                
                <!-- Alertas -->
                <div id="alertsContainer"></div>
                
                <!-- Gráficos -->
                <div class="charts-container">
                    <div class="chart-card">
                        <h3 class="chart-title">Despesas por Categoria</h3>
                        <div class="chart-wrapper">
                            <canvas id="expensesChart"></canvas>
                        </div>
                    </div>
                    
                    <div class="chart-card">
                        <h3 class="chart-title">Receita vs Despesa</h3>
                        <div class="chart-wrapper">
                            <canvas id="incomeVsExpensesChart"></canvas>
                        </div>
                    </div>
                    
                    <div class="chart-card">
                        <h3 class="chart-title">Evolução do Saldo</h3>
                        <div class="chart-wrapper">
                            <canvas id="balanceEvolutionChart"></canvas>
                        </div>
                    </div>
                </div>
            </section>
            
            <!-- Página: Transações -->
            <section id="transactions" class="page">
                <div class="transactions-container">
                    <div class="table-header">
                        <h2>Transações Financeiras</h2>
                        <div class="filters">
                            <select class="filter-select" id="filterType">
                                <option value="">Todos os Tipos</option>
                                <option value="Receita">Receita</option>
                                <option value="Despesa">Despesa</option>
                            </select>
                            <select class="filter-select" id="filterMonth">
                                <option value="">Todos os Meses</option>
                            </select>
                            <select class="filter-select" id="filterYear">
                                <option value="">Todos os Anos</option>
                            </select>
                            <select class="filter-select" id="filterCategory">
                                <option value="">Todas as Categorias</option>
                            </select>
                        </div>
                    </div>
                    
                    <div class="table-container">
                        <table class="transactions-table" id="transactionsTable">
                            <thead>
                                <tr>
                                    <th data-sort="date">Data</th>
                                    <th data-sort="month">Mês</th>
                                    <th data-sort="year">Ano</th>
                                    <th data-sort="category">Categoria</th>
                                    <th data-sort="subcategory">Subcategoria</th>
                                    <th data-sort="type">Tipo</th>
                                    <th data-sort="classification">Classificação</th>
                                    <th data-sort="value">Valor (R$)</th>
                                    <th data-sort="note">Observação</th>
                                    <th>Ações</th>
                                </tr>
                            </thead>
                            <tbody id="transactionsTableBody">
                                <!-- As transações serão inseridas aqui via JavaScript -->
                            </tbody>
                        </table>
                    </div>
                </div>
            </section>
            
            <!-- Página: Nova Transação -->
            <section id="add-transaction" class="page">
                <div class="form-container">
                    <h2 class="form-title">Adicionar Nova Transação</h2>
                    
                    <form id="transactionForm">
                        <div class="form-row">
                            <div class="form-group">
                                <label for="date">Data *</label>
                                <input type="date" id="date" required>
                            </div>
                            
                            <div class="form-group">
                                <label for="month">Mês *</label>
                                <input type="text" id="month" readonly>
                            </div>
                            
                            <div class="form-group">
                                <label for="year">Ano *</label>
                                <input type="text" id="year" readonly>
                            </div>
                        </div>
                        
                        <div class="form-row">
                            <div class="form-group">
                                <label for="category">Categoria *</label>
                                <input type="text" id="category" list="categories" placeholder="Ex: Alimentação, Transporte" required>
                                <datalist id="categories">
                                    <option value="Alimentação">
                                    <option value="Transporte">
                                    <option value="Moradia">
                                    <option value="Saúde">
                                    <option value="Educação">
                                    <option value="Lazer">
                                    <option value="Investimentos">
                                    <option value="Salário">
                                    <option value="Freelance">
                                    <option value="Outros">
                                </datalist>
                            </div>
                            
                            <div class="form-group">
                                <label for="subcategory">Subcategoria</label>
                                <input type="text" id="subcategory" placeholder="Ex: Supermercado, Uber">
                            </div>
                        </div>
                        
                        <div class="form-row">
                            <div class="form-group">
                                <label for="type">Tipo *</label>
                                <select id="type" required>
                                    <option value="">Selecione...</option>
                                    <option value="Receita">Receita</option>
                                    <option value="Despesa">Despesa</option>
                                </select>
                            </div>
                            
                            <div class="form-group">
                                <label for="classification">Classificação *</label>
                                <select id="classification" required>
                                    <option value="">Selecione...</option>
                                    <option value="Fixa">Fixa</option>
                                    <option value="Variável">Variável</option>
                                </select>
                            </div>
                            
                            <div class="form-group">
                                <label for="value">Valor (R$) *</label>
                                <input type="number" id="value" min="0.01" step="0.01" placeholder="0,00" required>
                            </div>
                        </div>
                        
                        <div class="form-group">
                            <label for="note">Observação</label>
                            <textarea id="note" rows="3" placeholder="Detalhes adicionais sobre a transação..."></textarea>
                        </div>
                        
                        <div class="form-actions">
                            <button type="button" class="btn btn-outline" id="cancelBtn">Cancelar</button>
                            <button type="submit" class="btn btn-primary">Salvar Transação</button>
                        </div>
                    </form>
                </div>
            </section>
            
            <!-- Página: Importar/Exportar -->
            <section id="import-export" class="page">
                <div class="import-export-container">
                    <!-- Importação -->
                    <div class="import-export-card">
                        <h3>Importar Dados</h3>
                        <p>Importe transações de arquivos CSV, XLSX ou PDF.</p>
                        
                        <div class="file-input" id="importDropArea">
                            <i class="fas fa-cloud-upload-alt" style="font-size: 2rem; margin-bottom: 10px;"></i>
                            <p>Arraste e solte arquivos aqui ou clique para selecionar</p>
                            <input type="file" id="importFile" accept=".csv,.xlsx,.xls,.pdf" hidden>
                        </div>
                        
                        <div class="form-group">
                            <label for="importType">Tipo de Arquivo</label>
                            <select id="importType" class="filter-select">
                                <option value="csv">CSV</option>
                                <option value="xlsx">Excel (XLSX)</option>
                                <option value="pdf">PDF</option>
                            </select>
                        </div>
                        
                        <button class="btn btn-primary" id="importBtn" style="margin-top: 20px;">
                            <i class="fas fa-file-import"></i> Importar Dados
                        </button>
                        
                        <div id="importStatus" style="margin-top: 15px;"></div>
                    </div>
                    
                    <!-- Exportação -->
                    <div class="import-export-card">
                        <h3>Exportar Dados</h3>
                        <p>Exporte suas transações para CSV ou gere relatórios em PDF.</p>
                        
                        <div class="form-group">
                            <label for="exportFormat">Formato de Exportação</label>
                            <select id="exportFormat" class="filter-select">
                                <option value="csv">CSV</option>
                                <option value="pdf">PDF (Relatório)</option>
                            </select>
                        </div>
                        
                        <div class="form-group">
                            <label for="exportDateRange">Período</label>
                            <select id="exportDateRange" class="filter-select">
                                <option value="all">Todos os dados</option>
                                <option value="month">Este mês</option>
                                <option value="year">Este ano</option>
                                <option value="custom">Personalizado</option>
                            </select>
                        </div>
                        
                        <div id="customDateRange" style="display: none; margin-top: 15px;">
                            <div class="form-row">
                                <div class="form-group">
                                    <label for="exportStartDate">Data Inicial</label>
                                    <input type="date" id="exportStartDate" class="filter-select">
                                </div>
                                <div class="form-group">
                                    <label for="exportEndDate">Data Final</label>
                                    <input type="date" id="exportEndDate" class="filter-select">
                                </div>
                            </div>
                        </div>
                        
                        <button class="btn btn-success" id="exportBtn" style="margin-top: 20px;">
                            <i class="fas fa-file-export"></i> Exportar Dados
                        </button>
                    </div>
                </div>
            </section>
            
            <!-- Página: Alertas e Limites -->
            <section id="limits" class="page">
                <div class="form-container">
                    <h2 class="form-title">Alertas e Limites de Gastos</h2>
                    
                    <div class="alert alert-warning">
                        <i class="fas fa-exclamation-triangle"></i>
                        <div>
                            <strong>Alerta de Despesas Fixas</strong>
                            <p>Configure limites para categorias específicas e receba alertas quando ultrapassar o valor definido.</p>
                        </div>
                    </div>
                    
                    <div id="limitsContainer">
                        <!-- Os limites serão gerados dinamicamente aqui -->
                    </div>
                    
                    <div class="form-actions">
                        <button class="btn btn-primary" id="addLimitBtn">
                            <i class="fas fa-plus"></i> Adicionar Novo Limite
                        </button>
                    </div>
                </div>
            </section>
        </main>
    </div>
    
    <!-- Modal para edição -->
    <div class="modal" id="editModal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">Editar Transação</h3>
                <button class="modal-close" id="closeEditModal">&times;</button>
            </div>
            <div class="modal-body">
                <form id="editForm">
                    <input type="hidden" id="editId">
                    <div class="form-row">
                        <div class="form-group">
                            <label for="editDate">Data</label>
                            <input type="date" id="editDate" required>
                        </div>
                        <div class="form-group">
                            <label for="editCategory">Categoria</label>
                            <input type="text" id="editCategory" required>
                        </div>
                    </div>
                    <div class="form-row">
                        <div class="form-group">
                            <label for="editType">Tipo</label>
                            <select id="editType" required>
                                <option value="Receita">Receita</option>
                                <option value="Despesa">Despesa</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="editValue">Valor (R$)</label>
                            <input type="number" id="editValue" min="0.01" step="0.01" required>
                        </div>
                    </div>
                    <div class="form-group">
                        <label for="editNote">Observação</label>
                        <textarea id="editNote" rows="3"></textarea>
                    </div>
                </form>
            </div>
            <div class="modal-footer">
                <button class="btn btn-outline" id="cancelEditBtn">Cancelar</button>
                <button class="btn btn-primary" id="saveEditBtn">Salvar Alterações</button>
            </div>
        </div>
    </div>
    
    <!-- Modal para confirmação -->
    <div class="modal" id="confirmModal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title">Confirmar Exclusão</h3>
                <button class="modal-close" id="closeConfirmModal">&times;</button>
            </div>
            <div class="modal-body">
                <p>Tem certeza que deseja excluir esta transação? Esta ação não pode ser desfeita.</p>
            </div>
            <div class="modal-footer">
                <button class="btn btn-outline" id="cancelDeleteBtn">Cancelar</button>
                <button class="btn btn-danger" id="confirmDeleteBtn">Excluir</button>
            </div>
        </div>
    </div>
    
    <!-- Modal para backup/restauração -->
    <div class="modal" id="backupModal">
        <div class="modal-content">
            <div class="modal-header">
                <h3 class="modal-title" id="backupModalTitle">Backup de Dados</h3>
                <button class="modal-close" id="closeBackupModal">&times;</button>
            </div>
            <div class="modal-body" id="backupModalBody">
                <!-- Conteúdo dinâmico -->
            </div>
        </div>
    </div>
    
   <script>
    /**
     * ============================================
     * SISTEMA DE CONTROLE FINANCEIRO PESSOAL
     * ============================================
     */
    
    // ============================================
    // CLASSE PRINCIPAL: AppController
    // ============================================
    class AppController {
        constructor() {
            this.database = new DatabaseService();
            this.transactionTable = new TransactionTable(this.database);
            this.transactionForm = new TransactionForm(this.database);
            this.dashboardController = new DashboardController(this.database);
            this.chartsController = new ChartsController(this.database);
            this.importExportService = new ImportExportService(this.database);
            this.themeManager = new ThemeManager();
            
            this.currentPage = 'dashboard';
            this.currentTransactionId = null;
            this.init();
        }

        /**
         * Inicializa a aplicação
         */
        async init() {
            try {
                await this.database.init();
                this.setupEventListeners();
                this.setupNavigation();
                await this.loadInitialData();
                this.themeManager.init();
                this.setupDragAndDrop();
                console.log('Aplicação inicializada com sucesso');
            } catch (error) {
                console.error('Erro na inicialização:', error);
            }
        }

        /**
         * Configura os listeners de eventos da aplicação
         */
        setupEventListeners() {
            // Navegação - CORREÇÃO: Event delegation para todos os links
            document.addEventListener('click', (e) => {
                const navLink = e.target.closest('.nav-link');
                if (navLink && !navLink.classList.contains('active')) {
                    e.preventDefault();
                    const page = navLink.getAttribute('data-page');
                    if (page) {
                        this.navigateTo(page);
                    }
                }
            });

            // Menu toggle (mobile)
            document.getElementById('menuToggle').addEventListener('click', () => {
                document.querySelector('.sidebar').classList.toggle('active');
            });

            // Botões de ação
            document.getElementById('backupBtn').addEventListener('click', () => this.showBackupModal());
            document.getElementById('restoreBtn').addEventListener('click', () => this.showRestoreModal());
            document.getElementById('cancelBtn').addEventListener('click', () => this.navigateTo('transactions'));
            document.getElementById('addLimitBtn').addEventListener('click', () => this.addNewLimit());

            // Filtros da tabela
            document.getElementById('filterType').addEventListener('change', () => this.transactionTable.filterTransactions());
            document.getElementById('filterMonth').addEventListener('change', () => this.transactionTable.filterTransactions());
            document.getElementById('filterYear').addEventListener('change', () => this.transactionTable.filterTransactions());
            document.getElementById('filterCategory').addEventListener('change', () => this.transactionTable.filterTransactions());

            // Modal de edição
            document.getElementById('closeEditModal').addEventListener('click', () => this.closeModal('editModal'));
            document.getElementById('cancelEditBtn').addEventListener('click', () => this.closeModal('editModal'));
            document.getElementById('saveEditBtn').addEventListener('click', () => this.saveEditedTransaction());

            // Modal de confirmação
            document.getElementById('closeConfirmModal').addEventListener('click', () => this.closeModal('confirmModal'));
            document.getElementById('cancelDeleteBtn').addEventListener('click', () => this.closeModal('confirmModal'));
            document.getElementById('confirmDeleteBtn').addEventListener('click', () => this.confirmDeleteTransaction());

            // Modal de backup
            document.getElementById('closeBackupModal').addEventListener('click', () => this.closeModal('backupModal'));

            // Importação/Exportação
            document.getElementById('importBtn').addEventListener('click', () => this.importExportService.handleImport());
            document.getElementById('exportBtn').addEventListener('click', () => this.importExportService.handleExport());
            document.getElementById('exportDateRange').addEventListener('change', (e) => {
                document.getElementById('customDateRange').style.display = 
                    e.target.value === 'custom' ? 'block' : 'none';
            });

            // Área de drop para importação
            const dropArea = document.getElementById('importDropArea');
            dropArea.addEventListener('click', () => document.getElementById('importFile').click());
            dropArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                dropArea.style.borderColor = 'var(--primary-color)';
            });
            dropArea.addEventListener('dragleave', () => {
                dropArea.style.borderColor = '';
            });
            dropArea.addEventListener('drop', (e) => {
                e.preventDefault();
                dropArea.style.borderColor = '';
                const files = e.dataTransfer.files;
                if (files.length) {
                    document.getElementById('importFile').files = files;
                    document.getElementById('importStatus').innerHTML = 
                        `<p style="color: var(--success-color)">Arquivo selecionado: ${files[0].name}</p>`;
                }
            });
            document.getElementById('importFile').addEventListener('change', (e) => {
                if (e.target.files.length) {
                    document.getElementById('importStatus').innerHTML = 
                        `<p style="color: var(--success-color)">Arquivo selecionado: ${e.target.files[0].name}</p>`;
                }
            });

            // Evento para botões dentro da tabela (delegação)
            document.addEventListener('click', (e) => {
                const editBtn = e.target.closest('.edit-transaction');
                if (editBtn) {
                    e.preventDefault();
                    const id = parseInt(editBtn.getAttribute('data-id'));
                    this.handleEditTransaction(id);
                }

                const deleteBtn = e.target.closest('.delete-transaction');
                if (deleteBtn) {
                    e.preventDefault();
                    const id = parseInt(deleteBtn.getAttribute('data-id'));
                    this.showDeleteModal(id);
                }
            });
        }

        /**
         * Configura a navegação inicial
         */
        setupNavigation() {
            // Garantir que apenas a dashboard esteja visível inicialmente
            document.querySelectorAll('.page').forEach(p => p.classList.remove('active'));
            document.querySelectorAll('.nav-link').forEach(link => link.classList.remove('active'));
            
            const initialPage = document.getElementById('dashboard');
            if (initialPage) {
                initialPage.classList.add('active');
            }
            
            const initialLink = document.querySelector('[data-page="dashboard"]');
            if (initialLink) {
                initialLink.classList.add('active');
            }
        }

        /**
         * Navega para uma página específica - CORREÇÃO COMPLETA
         * @param {string} page - Nome da página
         */
        async navigateTo(page) {
            console.log(`Navegando para: ${page}`);
            
            // Validar se a página existe
            const pageElement = document.getElementById(page);
            if (!pageElement) {
                console.error(`Página "${page}" não encontrada`);
                return;
            }
            
            // 1. Esconder todas as páginas
            document.querySelectorAll('.page').forEach(p => {
                p.classList.remove('active');
            });
            
            // 2. Remover classe active de todos os links do menu
            document.querySelectorAll('.nav-link').forEach(link => {
                link.classList.remove('active');
            });
            
            // 3. Mostrar página selecionada
            pageElement.classList.add('active');
            
            // 4. Ativar link correspondente no menu
            const navLink = document.querySelector(`[data-page="${page}"]`);
            if (navLink) {
                navLink.classList.add('active');
            }
            
            // 5. Atualizar título da página
            const titles = {
                'dashboard': 'Dashboard',
                'transactions': 'Transações',
                'add-transaction': 'Nova Transação',
                'import-export': 'Importar/Exportar',
                'limits': 'Alertas e Limites'
            };
            const titleElement = document.getElementById('pageTitle');
            if (titleElement && titles[page]) {
                titleElement.textContent = titles[page];
            }
            
            // 6. Fechar menu no mobile
            document.querySelector('.sidebar').classList.remove('active');
            
            // 7. Atualizar página atual
            this.currentPage = page;
            
            // 8. Carregar dados específicos da página
            await this.loadPageData(page);
        }

        /**
         * Carrega dados específicos para a página atual
         * @param {string} page - Nome da página
         */
        async loadPageData(page) {
            try {
                switch(page) {
                    case 'dashboard':
                        await this.dashboardController.updateDashboard();
                        await this.chartsController.updateAllCharts();
                        break;
                    case 'transactions':
                        await this.transactionTable.loadTransactions();
                        break;
                    case 'add-transaction':
                        // Resetar formulário ao navegar para ele
                        if (this.transactionForm && this.transactionForm.resetForm) {
                            this.transactionForm.resetForm();
                        }
                        break;
                    case 'limits':
                        await this.loadLimits();
                        break;
                }
            } catch (error) {
                console.error(`Erro ao carregar dados da página ${page}:`, error);
            }
        }

        /**
         * Carrega dados iniciais da aplicação
         */
        async loadInitialData() {
            try {
                // Carregar transações iniciais se o banco estiver vazio
                const count = await this.database.getTransactionCount();
                if (count === 0) {
                    await this.loadSampleData();
                }
                
                // Atualizar dashboard
                await this.dashboardController.updateDashboard();
                
                // Carregar gráficos
                await this.chartsController.updateAllCharts();
                
                // Carregar transações
                await this.transactionTable.loadTransactions();
                
                // Carregar limites
                await this.loadLimits();
                
                console.log('Dados iniciais carregados com sucesso');
            } catch (error) {
                console.error('Erro ao carregar dados iniciais:', error);
            }
        }

        /**
         * Carrega dados de exemplo para demonstração
         */
        async loadSampleData() {
            const sampleTransactions = [
                {
                    date: new Date().toISOString().split('T')[0],
                    month: new Date().toLocaleString('pt-BR', { month: 'long' }),
                    year: new Date().getFullYear(),
                    category: 'Salário',
                    subcategory: 'Salário Mensal',
                    type: 'Receita',
                    classification: 'Fixa',
                    value: 3500.00,
                    note: 'Salário do mês'
                },
                {
                    date: new Date().toISOString().split('T')[0],
                    month: new Date().toLocaleString('pt-BR', { month: 'long' }),
                    year: new Date().getFullYear(),
                    category: 'Alimentação',
                    subcategory: 'Supermercado',
                    type: 'Despesa',
                    classification: 'Variável',
                    value: 450.00,
                    note: 'Compras do mês'
                },
                {
                    date: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toISOString().split('T')[0],
                    month: new Date(Date.now() - 7 * 24 * 60 * 60 * 1000).toLocaleString('pt-BR', { month: 'long' }),
                    year: new Date().getFullYear(),
                    category: 'Transporte',
                    subcategory: 'Combustível',
                    type: 'Despesa',
                    classification: 'Variável',
                    value: 200.00,
                    note: 'Abastecimento do carro'
                }
            ];

            for (const transaction of sampleTransactions) {
                await this.database.addTransaction(transaction);
            }
        }

        /**
         * Carrega e exibe os limites configurados
         */
        async loadLimits() {
            try {
                const limits = await this.database.getAllLimits();
                const container = document.getElementById('limitsContainer');
                
                if (!container) return;
                
                if (limits.length === 0) {
                    container.innerHTML = `
                        <div class="alert alert-warning">
                            <i class="fas fa-info-circle"></i>
                            <div>
                                <strong>Nenhum limite configurado</strong>
                                <p>Adicione limites para categorias específicas para receber alertas quando ultrapassar o valor definido.</p>
                            </div>
                        </div>
                    `;
                    return;
                }

                let html = '';
                for (const limit of limits) {
                    const currentSpent = await this.database.getCategorySpentThisMonth(limit.category);
                    const percentage = (currentSpent / limit.limit) * 100;
                    const alertClass = percentage > 100 ? 'alert-danger' : percentage > 80 ? 'alert-warning' : '';
                    
                    html += `
                        <div class="card" style="margin-bottom: 15px;">
                            <div class="card-header">
                                <h3 class="card-title">${limit.category}</h3>
                                <button class="btn-icon btn-delete delete-limit" data-id="${limit.id}">
                                    <i class="fas fa-trash"></i>
                                </button>
                            </div>
                            <div class="card-value">Limite: R$ ${limit.limit.toFixed(2)}</div>
                            <p>Gasto este mês: <strong>R$ ${currentSpent.toFixed(2)}</strong> (${percentage.toFixed(1)}%)</p>
                            <div style="height: 10px; background: #eee; border-radius: 5px; margin-top: 10px;">
                                <div style="height: 100%; width: ${Math.min(percentage, 100)}%; 
                                     background: ${percentage > 100 ? 'var(--danger-color)' : percentage > 80 ? 'var(--warning-color)' : 'var(--success-color)'}; 
                                     border-radius: 5px;"></div>
                            </div>
                            ${alertClass ? `
                                <div class="alert ${alertClass}" style="margin-top: 10px;">
                                    <i class="fas fa-exclamation-triangle"></i>
                                    <div>
                                        <strong>Alerta!</strong>
                                        <p>${percentage > 100 ? 'Limite ultrapassado!' : 'Limite próximo do valor máximo.'}</p>
                                    </div>
                                </div>
                            ` : ''}
                        </div>
                    `;
                }
                
                container.innerHTML = html;
                
                // Adicionar listeners para botões de exclusão
                container.querySelectorAll('.delete-limit').forEach(btn => {
                    btn.addEventListener('click', async (e) => {
                        const id = parseInt(e.currentTarget.getAttribute('data-id'));
                        await this.database.deleteLimit(id);
                        await this.loadLimits();
                        await this.dashboardController.updateDashboard();
                    });
                });
            } catch (error) {
                console.error('Erro ao carregar limites:', error);
            }
        }

        /**
         * Adiciona um novo limite
         */
        async addNewLimit() {
            const category = prompt('Digite o nome da categoria para o limite:');
            if (!category) return;
            
            const limitStr = prompt('Digite o valor limite mensal (R$):');
            const limit = parseFloat(limitStr);
            
            if (isNaN(limit) || limit <= 0) {
                alert('Valor inválido!');
                return;
            }
            
            await this.database.addLimit({ category, limit });
            await this.loadLimits();
            await this.dashboardController.updateDashboard();
        }

        /**
         * Manipula a edição de transação
         */
        async handleEditTransaction(id) {
            try {
                const transaction = await this.database.getTransactionById(id);
                if (transaction) {
                    this.showEditModal(transaction);
                }
            } catch (error) {
                console.error('Erro ao carregar transação para edição:', error);
            }
        }

        /**
         * Mostra modal para edição de transação
         * @param {Object} transaction - Transação a ser editada
         */
        showEditModal(transaction) {
            this.currentTransactionId = transaction.id;
            
            document.getElementById('editId').value = transaction.id;
            document.getElementById('editDate').value = transaction.date;
            document.getElementById('editCategory').value = transaction.category;
            document.getElementById('editType').value = transaction.type;
            document.getElementById('editValue').value = transaction.value;
            document.getElementById('editNote').value = transaction.note || '';
            
            this.showModal('editModal');
        }

        /**
         * Salva a transação editada
         */
        async saveEditedTransaction() {
            try {
                const updatedTransaction = {
                    date: document.getElementById('editDate').value,
                    category: document.getElementById('editCategory').value,
                    type: document.getElementById('editType').value,
                    value: parseFloat(document.getElementById('editValue').value),
                    note: document.getElementById('editNote').value,
                    month: new Date(document.getElementById('editDate').value).toLocaleString('pt-BR', { month: 'long' }),
                    year: new Date(document.getElementById('editDate').value).getFullYear()
                };
                
                await this.database.updateTransaction(this.currentTransactionId, updatedTransaction);
                this.closeModal('editModal');
                await this.transactionTable.loadTransactions();
                await this.dashboardController.updateDashboard();
                await this.chartsController.updateAllCharts();
            } catch (error) {
                console.error('Erro ao salvar transação editada:', error);
                alert('Erro ao salvar transação: ' + error.message);
            }
        }

        /**
         * Mostra modal de confirmação para exclusão
         * @param {number} id - ID da transação a ser excluída
         */
        showDeleteModal(id) {
            this.currentTransactionId = id;
            this.showModal('confirmModal');
        }

        /**
         * Confirma e executa a exclusão da transação
         */
        async confirmDeleteTransaction() {
            try {
                await this.database.deleteTransaction(this.currentTransactionId);
                this.closeModal('confirmModal');
                await this.transactionTable.loadTransactions();
                await this.dashboardController.updateDashboard();
                await this.chartsController.updateAllCharts();
            } catch (error) {
                console.error('Erro ao excluir transação:', error);
                alert('Erro ao excluir transação: ' + error.message);
            }
        }

        /**
         * Mostra modal de backup/restauração
         */
        showBackupModal() {
            document.getElementById('backupModalTitle').textContent = 'Backup de Dados';
            document.getElementById('backupModalBody').innerHTML = `
                <p>Faça backup completo dos seus dados financeiros.</p>
                <button class="btn btn-primary" id="generateBackupBtn" style="width: 100%; margin-bottom: 10px;">
                    <i class="fas fa-download"></i> Gerar Backup
                </button>
                <p><small>O backup será baixado como um arquivo JSON que você pode restaurar posteriormente.</small></p>
            `;
            
            this.showModal('backupModal');
            
            document.getElementById('generateBackupBtn').addEventListener('click', async () => {
                try {
                    await this.importExportService.generateBackup();
                    this.closeModal('backupModal');
                } catch (error) {
                    alert(`Erro ao gerar backup: ${error.message}`);
                }
            });
        }

        /**
         * Mostra modal de restauração
         */
        showRestoreModal() {
            document.getElementById('backupModalTitle').textContent = 'Restaurar Backup';
            document.getElementById('backupModalBody').innerHTML = `
                <p>Restaurar dados a partir de um arquivo de backup.</p>
                <div class="file-input" id="restoreDropArea" style="margin-bottom: 15px;">
                    <i class="fas fa-cloud-upload-alt" style="font-size: 2rem; margin-bottom: 10px;"></i>
                    <p>Arraste e solte o arquivo de backup aqui</p>
                    <input type="file" id="restoreFile" accept=".json" hidden>
                </div>
                <button class="btn btn-success" id="restoreBackupBtn" style="width: 100%;" disabled>
                    <i class="fas fa-upload"></i> Restaurar Backup
                </button>
                <p style="margin-top: 15px;"><small><strong>Atenção:</strong> Esta ação substituirá todos os dados atuais.</small></p>
            `;
            
            this.showModal('backupModal');
            
            const dropArea = document.getElementById('restoreDropArea');
            const fileInput = document.getElementById('restoreFile');
            const restoreBtn = document.getElementById('restoreBackupBtn');
            
            dropArea.addEventListener('click', () => fileInput.click());
            dropArea.addEventListener('dragover', (e) => {
                e.preventDefault();
                dropArea.style.borderColor = 'var(--primary-color)';
            });
            dropArea.addEventListener('dragleave', () => {
                dropArea.style.borderColor = '';
            });
            dropArea.addEventListener('drop', (e) => {
                e.preventDefault();
                dropArea.style.borderColor = '';
                const files = e.dataTransfer.files;
                if (files.length) {
                    fileInput.files = files;
                    restoreBtn.disabled = false;
                }
            });
            
            fileInput.addEventListener('change', (e) => {
                if (e.target.files.length) {
                    restoreBtn.disabled = false;
                }
            });
            
            restoreBtn.addEventListener('click', async () => {
                if (fileInput.files.length) {
                    try {
                        await this.importExportService.restoreBackup(fileInput.files[0]);
                        this.closeModal('backupModal');
                        // Recarregar todos os dados
                        await this.loadInitialData();
                        this.navigateTo('dashboard');
                    } catch (error) {
                        alert(`Erro ao restaurar backup: ${error.message}`);
                    }
                }
            });
        }

        /**
         * Mostra um modal específico
         * @param {string} modalId - ID do modal
         */
        showModal(modalId) {
            document.getElementById(modalId).classList.add('active');
        }

        /**
         * Fecha um modal específico
         * @param {string} modalId - ID do modal
         */
        closeModal(modalId) {
            document.getElementById(modalId).classList.remove('active');
        }

        /**
         * Configura funcionalidade de arrastar e soltar para os cards
         */
        setupDragAndDrop() {
            const cards = document.querySelectorAll('.card[draggable="true"]');
            const container = document.getElementById('dashboardCards');
            
            if (!container) return;
            
            cards.forEach(card => {
                card.addEventListener('dragstart', (e) => {
                    e.dataTransfer.setData('text/plain', card.id || 'card');
                    card.classList.add('dragging');
                });
                
                card.addEventListener('dragend', () => {
                    card.classList.remove('dragging');
                });
            });
            
            container.addEventListener('dragover', (e) => {
                e.preventDefault();
                const afterElement = this.getDragAfterElement(container, e.clientY);
                const draggable = document.querySelector('.dragging');
                
                if (draggable) {
                    if (afterElement == null) {
                        container.appendChild(draggable);
                    } else {
                        container.insertBefore(draggable, afterElement);
                    }
                }
            });
        }

        /**
         * Calcula a posição do elemento durante o arrasto
         */
        getDragAfterElement(container, y) {
            const draggableElements = [...container.querySelectorAll('.card:not(.dragging)')];
            
            return draggableElements.reduce((closest, child) => {
                const box = child.getBoundingClientRect();
                const offset = y - box.top - box.height / 2;
                
                if (offset < 0 && offset > closest.offset) {
                    return { offset: offset, element: child };
                } else {
                    return closest;
                }
            }, { offset: Number.NEGATIVE_INFINITY }).element;
        }
    }

    // ============================================
    // CLASSE: DatabaseService
    // ============================================
    class DatabaseService {
        constructor() {
            this.db = null;
            this.dbName = 'PersonalFinanceDB';
            this.dbVersion = 1;
        }

        /**
         * Inicializa o banco de dados IndexedDB
         * @returns {Promise} - Promessa de inicialização
         */
        async init() {
            return new Promise((resolve, reject) => {
                const request = indexedDB.open(this.dbName, this.dbVersion);
                
                request.onerror = () => {
                    console.error('Erro ao abrir o banco de dados');
                    reject(request.error);
                };
                
                request.onsuccess = () => {
                    this.db = request.result;
                    console.log('Banco de dados inicializado');
                    resolve();
                };
                
                request.onupgradeneeded = (event) => {
                    const db = event.target.result;
                    
                    // Criação do objeto de transações
                    if (!db.objectStoreNames.contains('transactions')) {
                        const transactionStore = db.createObjectStore('transactions', { 
                            keyPath: 'id', 
                            autoIncrement: true 
                        });
                        
                        // Cria índices para consultas eficientes
                        transactionStore.createIndex('date', 'date', { unique: false });
                        transactionStore.createIndex('month', 'month', { unique: false });
                        transactionStore.createIndex('year', 'year', { unique: false });
                        transactionStore.createIndex('category', 'category', { unique: false });
                        transactionStore.createIndex('type', 'type', { unique: false });
                        transactionStore.createIndex('classification', 'classification', { unique: false });
                    }
                    
                    // Criação do objeto de limites
                    if (!db.objectStoreNames.contains('limits')) {
                        const limitStore = db.createObjectStore('limits', { 
                            keyPath: 'id', 
                            autoIncrement: true 
                        });
                        
                        limitStore.createIndex('category', 'category', { unique: true });
                    }
                    
                    console.log('Estrutura do banco de dados criada/atualizada');
                };
            });
        }

        /**
         * Obtém o número total de transações
         * @returns {Promise<number>} - Número de transações
         */
        async getTransactionCount() {
            return new Promise((resolve, reject) => {
                if (!this.db) {
                    reject(new Error('Banco de dados não inicializado'));
                    return;
                }
                
                const transaction = this.db.transaction(['transactions'], 'readonly');
                const store = transaction.objectStore('transactions');
                const request = store.count();
                
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }

        /**
         * Adiciona uma nova transação
         * @param {Object} transaction - Dados da transação
         * @returns {Promise<number>} - ID da transação criada
         */
        async addTransaction(transaction) {
            return new Promise((resolve, reject) => {
                if (!this.db) {
                    reject(new Error('Banco de dados não inicializado'));
                    return;
                }
                
                const transactionDB = this.db.transaction(['transactions'], 'readwrite');
                const store = transactionDB.objectStore('transactions');
                
                // Adiciona mês e ano se não estiverem presentes
                if (!transaction.month && transaction.date) {
                    const date = new Date(transaction.date);
                    transaction.month = date.toLocaleString('pt-BR', { month: 'long' });
                    transaction.year = date.getFullYear();
                }
                
                const request = store.add(transaction);
                
                request.onsuccess = () => {
                    console.log('Transação adicionada com ID:', request.result);
                    resolve(request.result);
                };
                request.onerror = () => reject(request.error);
            });
        }

        /**
         * Obtém todas as transações
         * @returns {Promise<Array>} - Lista de transações
         */
        async getAllTransactions() {
            return new Promise((resolve, reject) => {
                if (!this.db) {
                    reject(new Error('Banco de dados não inicializado'));
                    return;
                }
                
                const transaction = this.db.transaction(['transactions'], 'readonly');
                const store = transaction.objectStore('transactions');
                const request = store.getAll();
                
                request.onsuccess = () => resolve(request.result || []);
                request.onerror = () => reject(request.error);
            });
        }

        /**
         * Obtém transações filtradas
         * @param {Object} filters - Filtros a serem aplicados
         * @returns {Promise<Array>} - Transações filtradas
         */
        async getFilteredTransactions(filters = {}) {
            try {
                const allTransactions = await this.getAllTransactions();
                let filtered = [...allTransactions];
                
                // Aplicar filtros
                if (filters.type && filters.type !== '') {
                    filtered = filtered.filter(t => t.type === filters.type);
                }
                
                if (filters.month && filters.month !== '') {
                    filtered = filtered.filter(t => t.month === filters.month);
                }
                
                if (filters.year && filters.year !== '') {
                    filtered = filtered.filter(t => t.year.toString() === filters.year);
                }
                
                if (filters.category && filters.category !== '') {
                    filtered = filtered.filter(t => t.category === filters.category);
                }
                
                return filtered;
            } catch (error) {
                console.error('Erro ao filtrar transações:', error);
                return [];
            }
        }

        /**
         * Atualiza uma transação existente
         * @param {number} id - ID da transação
         * @param {Object} updates - Dados atualizados
         * @returns {Promise} - Promessa de atualização
         */
        async updateTransaction(id, updates) {
            return new Promise(async (resolve, reject) => {
                if (!this.db) {
                    reject(new Error('Banco de dados não inicializado'));
                    return;
                }
                
                // Primeiro, obtém a transação existente
                try {
                    const existing = await this.getTransactionById(id);
                    if (!existing) {
                        reject(new Error('Transação não encontrada'));
                        return;
                    }
                    
                    // Atualiza os dados
                    const updatedTransaction = { ...existing, ...updates };
                    
                    const transaction = this.db.transaction(['transactions'], 'readwrite');
                    const store = transaction.objectStore('transactions');
                    const request = store.put(updatedTransaction);
                    
                    request.onsuccess = () => {
                        console.log('Transação atualizada com ID:', id);
                        resolve(request.result);
                    };
                    request.onerror = () => reject(request.error);
                } catch (error) {
                    reject(error);
                }
            });
        }

        /**
         * Obtém uma transação por ID
         * @param {number} id - ID da transação
         * @returns {Promise<Object>} - Transação encontrada
         */
        async getTransactionById(id) {
            return new Promise((resolve, reject) => {
                if (!this.db) {
                    reject(new Error('Banco de dados não inicializado'));
                    return;
                }
                
                const transaction = this.db.transaction(['transactions'], 'readonly');
                const store = transaction.objectStore('transactions');
                const request = store.get(id);
                
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }

        /**
         * Exclui uma transação
         * @param {number} id - ID da transação
         * @returns {Promise} - Promessa de exclusão
         */
        async deleteTransaction(id) {
            return new Promise((resolve, reject) => {
                if (!this.db) {
                    reject(new Error('Banco de dados não inicializado'));
                    return;
                }
                
                const transaction = this.db.transaction(['transactions'], 'readwrite');
                const store = transaction.objectStore('transactions');
                const request = store.delete(id);
                
                request.onsuccess = () => {
                    console.log('Transação excluída com ID:', id);
                    resolve();
                };
                request.onerror = () => reject(request.error);
            });
        }

        /**
         * Obtém totais financeiros
         * @returns {Promise<Object>} - Totais (receitas, despesas, saldo)
         */
        async getFinancialTotals() {
            try {
                const transactions = await this.getAllTransactions();
                
                let totalIncome = 0;
                let totalExpenses = 0;
                let totalInvested = 0;
                
                transactions.forEach(transaction => {
                    if (transaction.type === 'Receita') {
                        totalIncome += transaction.value;
                        if (transaction.category === 'Investimentos') {
                            totalInvested += transaction.value;
                        }
                    } else if (transaction.type === 'Despesa') {
                        totalExpenses += transaction.value;
                    }
                });
                
                const currentBalance = totalIncome - totalExpenses;
                
                // Calcular retorno de investimentos (simulado)
                const investmentReturn = totalInvested > 0 ? (totalInvested * 0.05).toFixed(2) : 0;
                
                // Calcular totais do mês anterior
                const currentDate = new Date();
                const lastMonth = currentDate.getMonth() === 0 ? 11 : currentDate.getMonth() - 1;
                const lastMonthYear = currentDate.getMonth() === 0 ? currentDate.getFullYear() - 1 : currentDate.getFullYear();
                
                const lastMonthTransactions = transactions.filter(t => {
                    const monthNames = ['janeiro', 'fevereiro', 'março', 'abril', 'maio', 'junho', 
                                       'julho', 'agosto', 'setembro', 'outubro', 'novembro', 'dezembro'];
                    const transactionMonth = monthNames.indexOf(t.month.toLowerCase());
                    return transactionMonth === lastMonth && t.year === lastMonthYear;
                });
                
                let lastMonthIncome = 0;
                let lastMonthExpenses = 0;
                
                lastMonthTransactions.forEach(transaction => {
                    if (transaction.type === 'Receita') {
                        lastMonthIncome += transaction.value;
                    } else if (transaction.type === 'Despesa') {
                        lastMonthExpenses += transaction.value;
                    }
                });
                
                return {
                    totalIncome,
                    totalExpenses,
                    currentBalance,
                    totalInvested,
                    investmentReturn,
                    lastMonthIncome,
                    lastMonthExpenses
                };
            } catch (error) {
                console.error('Erro ao calcular totais financeiros:', error);
                return {
                    totalIncome: 0,
                    totalExpenses: 0,
                    currentBalance: 0,
                    totalInvested: 0,
                    investmentReturn: 0,
                    lastMonthIncome: 0,
                    lastMonthExpenses: 0
                };
            }
        }

        /**
         * Obtém categorias únicas das transações
         * @returns {Promise<Array>} - Lista de categorias
         */
        async getUniqueCategories() {
            try {
                const transactions = await this.getAllTransactions();
                const categories = [...new Set(transactions.map(t => t.category))];
                return categories.sort();
            } catch (error) {
                console.error('Erro ao obter categorias únicas:', error);
                return [];
            }
        }

        /**
         * Obtém meses únicos das transações
         * @returns {Promise<Array>} - Lista de meses
         */
        async getUniqueMonths() {
            try {
                const transactions = await this.getAllTransactions();
                const months = [...new Set(transactions.map(t => t.month))];
                
                // Ordenar meses cronologicamente
                const monthOrder = ['janeiro', 'fevereiro', 'março', 'abril', 'maio', 'junho', 
                                   'julho', 'agosto', 'setembro', 'outubro', 'novembro', 'dezembro'];
                
                return months.sort((a, b) => {
                    return monthOrder.indexOf(a.toLowerCase()) - monthOrder.indexOf(b.toLowerCase());
                });
            } catch (error) {
                console.error('Erro ao obter meses únicos:', error);
                return [];
            }
        }

        /**
         * Obtém anos únicos das transações
         * @returns {Promise<Array>} - Lista de anos
         */
        async getUniqueYears() {
            try {
                const transactions = await this.getAllTransactions();
                const years = [...new Set(transactions.map(t => t.year))];
                return years.sort((a, b) => b - a); // Ordem decrescente
            } catch (error) {
                console.error('Erro ao obter anos únicos:', error);
                return [];
            }
        }

        /**
         * Obtém despesas por categoria para um período específico
         * @param {string} month - Mês (opcional)
         * @param {number} year - Ano (opcional)
         * @returns {Promise<Object>} - Despesas agrupadas por categoria
         */
        async getExpensesByCategory(month = null, year = null) {
            try {
                const transactions = await this.getAllTransactions();
                
                // Filtrar apenas despesas
                let expenses = transactions.filter(t => t.type === 'Despesa');
                
                // Filtrar por mês/ano se especificado
                if (month) {
                    expenses = expenses.filter(t => t.month === month);
                }
                
                if (year) {
                    expenses = expenses.filter(t => t.year === year);
                }
                
                // Agrupar por categoria
                const grouped = {};
                expenses.forEach(expense => {
                    if (!grouped[expense.category]) {
                        grouped[expense.category] = 0;
                    }
                    grouped[expense.category] += expense.value;
                });
                
                return grouped;
            } catch (error) {
                console.error('Erro ao obter despesas por categoria:', error);
                return {};
            }
        }

        /**
         * Obtém evolução mensal do saldo
         * @returns {Promise<Array>} - Dados de evolução do saldo
         */
        async getBalanceEvolution() {
            try {
                const transactions = await this.getAllTransactions();
                
                // Agrupar transações por mês/ano
                const grouped = {};
                transactions.forEach(transaction => {
                    const key = `${transaction.month}/${transaction.year}`;
                    if (!grouped[key]) {
                        grouped[key] = { income: 0, expenses: 0, balance: 0 };
                    }
                    
                    if (transaction.type === 'Receita') {
                        grouped[key].income += transaction.value;
                    } else {
                        grouped[key].expenses += transaction.value;
                    }
                    
                    grouped[key].balance = grouped[key].income - grouped[key].expenses;
                });
                
                // Converter para array e ordenar
                const result = Object.keys(grouped).map(key => {
                    const [month, year] = key.split('/');
                    return {
                        month,
                        year: parseInt(year),
                        income: grouped[key].income,
                        expenses: grouped[key].expenses,
                        balance: grouped[key].balance
                    };
                });
                
                // Ordenar cronologicamente
                const monthOrder = ['janeiro', 'fevereiro', 'março', 'abril', 'maio', 'junho', 
                                   'julho', 'agosto', 'setembro', 'outubro', 'novembro', 'dezembro'];
                
                return result.sort((a, b) => {
                    if (a.year !== b.year) return a.year - b.year;
                    return monthOrder.indexOf(a.month.toLowerCase()) - monthOrder.indexOf(b.month.toLowerCase());
                });
            } catch (error) {
                console.error('Erro ao obter evolução do saldo:', error);
                return [];
            }
        }

        /**
         * Adiciona um novo limite de gastos
         * @param {Object} limit - Dados do limite
         * @returns {Promise<number>} - ID do limite criado
         */
        async addLimit(limit) {
            return new Promise((resolve, reject) => {
                if (!this.db) {
                    reject(new Error('Banco de dados não inicializado'));
                    return;
                }
                
                const transaction = this.db.transaction(['limits'], 'readwrite');
                const store = transaction.objectStore('limits');
                const request = store.add(limit);
                
                request.onsuccess = () => resolve(request.result);
                request.onerror = () => reject(request.error);
            });
        }

        /**
         * Obtém todos os limites
         * @returns {Promise<Array>} - Lista de limites
         */
        async getAllLimits() {
            return new Promise((resolve, reject) => {
                if (!this.db) {
                    reject(new Error('Banco de dados não inicializado'));
                    return;
                }
                
                const transaction = this.db.transaction(['limits'], 'readonly');
                const store = transaction.objectStore('limits');
                const request = store.getAll();
                
                request.onsuccess = () => resolve(request.result || []);
                request.onerror = () => reject(request.error);
            });
        }

        /**
         * Exclui um limite
         * @param {number} id - ID do limite
         * @returns {Promise} - Promessa de exclusão
         */
        async deleteLimit(id) {
            return new Promise((resolve, reject) => {
                if (!this.db) {
                    reject(new Error('Banco de dados não inicializado'));
                    return;
                }
                
                const transaction = this.db.transaction(['limits'], 'readwrite');
                const store = transaction.objectStore('limits');
                const request = store.delete(id);
                
                request.onsuccess = () => resolve();
                request.onerror = () => reject(request.error);
            });
        }

        /**
         * Obtém o total gasto em uma categoria no mês atual
         * @param {string} category - Categoria
         * @returns {Promise<number>} - Total gasto
         */
        async getCategorySpentThisMonth(category) {
            try {
                const transactions = await this.getAllTransactions();
                const currentDate = new Date();
                const currentMonth = currentDate.toLocaleString('pt-BR', { month: 'long' });
                const currentYear = currentDate.getFullYear();
                
                const categoryTransactions = transactions.filter(t => 
                    t.category === category && 
                    t.type === 'Despesa' &&
                    t.month === currentMonth &&
                    t.year === currentYear
                );
                
                return categoryTransactions.reduce((total, t) => total + t.value, 0);
            } catch (error) {
                console.error('Erro ao obter gasto da categoria:', error);
                return 0;
            }
        }

        /**
         * Obtém alertas financeiros (limites ultrapassados)
         * @returns {Promise<Array>} - Lista de alertas
         */
        async getFinancialAlerts() {
            try {
                const limits = await this.getAllLimits();
                const alerts = [];
                
                for (const limit of limits) {
                    const spent = await this.getCategorySpentThisMonth(limit.category);
                    const percentage = (spent / limit.limit) * 100;
                    
                    if (percentage > 100) {
                        alerts.push({
                            type: 'danger',
                            category: limit.category,
                            message: `Limite ultrapassado em ${limit.category}! Gasto: R$ ${spent.toFixed(2)} / Limite: R$ ${limit.limit.toFixed(2)}`,
                            percentage: percentage
                        });
                    } else if (percentage > 80) {
                        alerts.push({
                            type: 'warning',
                            category: limit.category,
                            message: `Limite próximo em ${limit.category}! Gasto: R$ ${spent.toFixed(2)} / Limite: R$ ${limit.limit.toFixed(2)}`,
                            percentage: percentage
                        });
                    }
                }
                
                return alerts;
            } catch (error) {
                console.error('Erro ao obter alertas financeiros:', error);
                return [];
            }
        }

        /**
         * Exporta todos os dados do banco
         * @returns {Promise<Object>} - Dados completos do banco
         */
        async exportAllData() {
            try {
                const transactions = await this.getAllTransactions();
                const limits = await this.getAllLimits();
                
                return {
                    transactions,
                    limits,
                    exportDate: new Date().toISOString(),
                    version: '1.0'
                };
            } catch (error) {
                console.error('Erro ao exportar dados:', error);
                throw error;
            }
        }

        /**
         * Importa dados para o banco
         * @param {Object} data - Dados a serem importados
         * @returns {Promise} - Promessa de importação
         */
        async importData(data) {
            return new Promise(async (resolve, reject) => {
                if (!this.db) {
                    reject(new Error('Banco de dados não inicializado'));
                    return;
                }
                
                try {
                    // Validar estrutura dos dados
                    if (!data.transactions || !Array.isArray(data.transactions)) {
                        throw new Error('Estrutura de dados inválida');
                    }
                    
                    // Limpar dados existentes
                    await this.clearAllData();
                    
                    // Importar transações
                    for (const transaction of data.transactions) {
                        await this.addTransaction(transaction);
                    }
                    
                    // Importar limites se existirem
                    if (data.limits && Array.isArray(data.limits)) {
                        for (const limit of data.limits) {
                            await this.addLimit(limit);
                        }
                    }
                    
                    resolve();
                } catch (error) {
                    reject(error);
                }
            });
        }

        /**
         * Limpa todos os dados do banco
         * @returns {Promise} - Promessa de limpeza
         */
        async clearAllData() {
            return new Promise(async (resolve, reject) => {
                if (!this.db) {
                    reject(new Error('Banco de dados não inicializado'));
                    return;
                }
                
                const transaction = this.db.transaction(['transactions', 'limits'], 'readwrite');
                
                const clearStore = (storeName) => {
                    return new Promise((resolveStore, rejectStore) => {
                        const store = transaction.objectStore(storeName);
                        const request = store.clear();
                        
                        request.onsuccess = () => resolveStore();
                        request.onerror = () => rejectStore(request.error);
                    });
                };
                
                try {
                    await clearStore('transactions');
                    await clearStore('limits');
                    resolve();
                } catch (error) {
                    reject(error);
                }
            });
        }
    }

    // ============================================
    // CLASSE: TransactionTable
    // ============================================
    class TransactionTable {
        constructor(database) {
            this.database = database;
            this.currentSort = { column: 'date', direction: 'desc' };
            this.currentFilters = {};
        }

        /**
         * Carrega e exibe as transações
         */
        async loadTransactions() {
            try {
                const transactions = await this.database.getFilteredTransactions(this.currentFilters);
                
                // Ordenar transações
                transactions.sort(this.getSortFunction());
                
                // Atualizar tabela
                this.renderTable(transactions);
                
                // Atualizar filtros
                await this.updateFilterOptions();
                
                // Atualizar indicadores de ordenação
                this.updateSortIndicators();
            } catch (error) {
                console.error('Erro ao carregar transações:', error);
            }
        }

        /**
         * Renderiza a tabela de transações
         * @param {Array} transactions - Lista de transações
         */
        renderTable(transactions) {
            const tbody = document.getElementById('transactionsTableBody');
            if (!tbody) return;
            
            if (transactions.length === 0) {
                tbody.innerHTML = `
                    <tr>
                        <td colspan="10" style="text-align: center; padding: 40px;">
                            <i class="fas fa-receipt" style="font-size: 3rem; color: var(--gray-color); margin-bottom: 10px;"></i>
                            <p>Nenhuma transação encontrada.</p>
                            <button class="btn btn-primary" onclick="window.app.navigateTo('add-transaction')">
                                <i class="fas fa-plus"></i> Adicionar Primeira Transação
                            </button>
                        </td>
                    </tr>
                `;
                return;
            }
            
            let html = '';
            
            transactions.forEach(transaction => {
                const valueClass = transaction.type === 'Receita' ? 'income' : 'expense';
                const valuePrefix = transaction.type === 'Receita' ? '+' : '-';
                
                html += `
                    <tr>
                        <td>${this.formatDate(transaction.date)}</td>
                        <td>${transaction.month}</td>
                        <td>${transaction.year}</td>
                        <td>${transaction.category}</td>
                        <td>${transaction.subcategory || '-'}</td>
                        <td>${transaction.type}</td>
                        <td>${transaction.classification}</td>
                        <td class="${valueClass}">${valuePrefix} R$ ${transaction.value.toFixed(2)}</td>
                        <td>${transaction.note || '-'}</td>
                        <td>
                            <div class="action-buttons">
                                <button class="btn-icon btn-edit edit-transaction" data-id="${transaction.id}">
                                    <i class="fas fa-edit"></i>
                                </button>
                                <button class="btn-icon btn-delete delete-transaction" data-id="${transaction.id}">
                                    <i class="fas fa-trash"></i>
                                </button>
                            </div>
                        </td>
                    </tr>
                `;
            });
            
            tbody.innerHTML = html;
            
            // Adicionar listeners para ordenação
            const headers = document.querySelectorAll('.transactions-table th[data-sort]');
            headers.forEach(th => {
                th.addEventListener('click', () => {
                    const column = th.getAttribute('data-sort');
                    this.sortTable(column);
                });
            });
        }

        /**
         * Formata uma data para exibição
         * @param {string} dateString - Data no formato ISO
         * @returns {string} - Data formatada
         */
        formatDate(dateString) {
            try {
                const date = new Date(dateString);
                return date.toLocaleDateString('pt-BR');
            } catch (error) {
                return dateString;
            }
        }

        /**
         * Atualiza as opções disponíveis nos filtros
         */
        async updateFilterOptions() {
            try {
                // Carregar opções únicas
                const categories = await this.database.getUniqueCategories();
                const months = await this.database.getUniqueMonths();
                const years = await this.database.getUniqueYears();
                
                // Atualizar filtro de categorias
                const categoryFilter = document.getElementById('filterCategory');
                if (categoryFilter) {
                    let categoryOptions = '<option value="">Todas as Categorias</option>';
                    categories.forEach(category => {
                        categoryOptions += `<option value="${category}">${category}</option>`;
                    });
                    categoryFilter.innerHTML = categoryOptions;
                    
                    // Manter a seleção atual se existir
                    if (this.currentFilters.category) {
                        categoryFilter.value = this.currentFilters.category;
                    }
                }
                
                // Atualizar filtro de meses
                const monthFilter = document.getElementById('filterMonth');
                if (monthFilter) {
                    let monthOptions = '<option value="">Todos os Meses</option>';
                    months.forEach(month => {
                        monthOptions += `<option value="${month}">${month}</option>`;
                    });
                    monthFilter.innerHTML = monthOptions;
                    
                    // Manter a seleção atual se existir
                    if (this.currentFilters.month) {
                        monthFilter.value = this.currentFilters.month;
                    }
                }
                
                // Atualizar filtro de anos
                const yearFilter = document.getElementById('filterYear');
                if (yearFilter) {
                    let yearOptions = '<option value="">Todos os Anos</option>';
                    years.forEach(year => {
                        yearOptions += `<option value="${year}">${year}</option>`;
                    });
                    yearFilter.innerHTML = yearOptions;
                    
                    // Manter a seleção atual se existir
                    if (this.currentFilters.year) {
                        yearFilter.value = this.currentFilters.year;
                    }
                }
            } catch (error) {
                console.error('Erro ao atualizar filtros:', error);
            }
        }

        /**
         * Aplica filtros às transações
         */
        filterTransactions() {
            // Coletar valores dos filtros
            this.currentFilters = {
                type: document.getElementById('filterType')?.value || '',
                month: document.getElementById('filterMonth')?.value || '',
                year: document.getElementById('filterYear')?.value || '',
                category: document.getElementById('filterCategory')?.value || ''
            };
            
            // Recarregar transações com os filtros aplicados
            this.loadTransactions();
        }

        /**
         * Ordena a tabela por uma coluna específica
         * @param {string} column - Coluna para ordenação
         */
        sortTable(column) {
            // Alternar direção se for a mesma coluna
            if (this.currentSort.column === column) {
                this.currentSort.direction = this.currentSort.direction === 'asc' ? 'desc' : 'asc';
            } else {
                this.currentSort.column = column;
                this.currentSort.direction = 'asc';
            }
            
            // Recarregar transações com a nova ordenação
            this.loadTransactions();
        }

        /**
         * Retorna função de ordenação baseada na coluna atual
         * @returns {Function} - Função de ordenação
         */
        getSortFunction() {
            return (a, b) => {
                let aValue = a[this.currentSort.column];
                let bValue = b[this.currentSort.column];
                
                // Tratamento especial para datas
                if (this.currentSort.column === 'date') {
                    aValue = new Date(aValue);
                    bValue = new Date(bValue);
                }
                
                // Tratamento especial para valores monetários
                if (this.currentSort.column === 'value') {
                    aValue = parseFloat(aValue);
                    bValue = parseFloat(bValue);
                }
                
                // Comparação
                if (aValue < bValue) {
                    return this.currentSort.direction === 'asc' ? -1 : 1;
                }
                if (aValue > bValue) {
                    return this.currentSort.direction === 'asc' ? 1 : -1;
                }
                return 0;
            };
        }

        /**
         * Atualiza indicadores visuais de ordenação na tabela
         */
        updateSortIndicators() {
            // Remover indicadores anteriores
            document.querySelectorAll('.transactions-table th').forEach(th => {
                th.classList.remove('sort-asc', 'sort-desc');
            });
            
            // Adicionar indicador atual
            const currentTh = document.querySelector(`.transactions-table th[data-sort="${this.currentSort.column}"]`);
            if (currentTh) {
                currentTh.classList.add(`sort-${this.currentSort.direction}`);
            }
        }
    }

    // ============================================
    // CLASSE: TransactionForm
    // ============================================
    class TransactionForm {
        constructor(database) {
            this.database = database;
            this.initializeForm();
        }

        /**
         * Inicializa o formulário com listeners e comportamentos
         */
        initializeForm() {
            // Auto-preencher mês e ano baseado na data
            const dateInput = document.getElementById('date');
            const monthInput = document.getElementById('month');
            const yearInput = document.getElementById('year');
            
            if (dateInput && monthInput && yearInput) {
                dateInput.addEventListener('change', () => {
                    if (dateInput.value) {
                        const date = new Date(dateInput.value);
                        monthInput.value = date.toLocaleString('pt-BR', { month: 'long' });
                        yearInput.value = date.getFullYear();
                    }
                });
                
                // Configurar data atual como padrão
                const today = new Date().toISOString().split('T')[0];
                dateInput.value = today;
                dateInput.dispatchEvent(new Event('change'));
            }
            
            // Configurar máscara monetária
            const valueInput = document.getElementById('value');
            if (valueInput) {
                valueInput.addEventListener('blur', () => {
                    if (valueInput.value) {
                        const value = parseFloat(valueInput.value);
                        if (!isNaN(value)) {
                            valueInput.value = value.toFixed(2);
                        }
                    }
                });
            }
            
            // Configurar envio do formulário
            const form = document.getElementById('transactionForm');
            if (form) {
                form.addEventListener('submit', (e) => {
                    e.preventDefault();
                    this.handleSubmit();
                });
            }
        }

        /**
         * Processa o envio do formulário
         */
        async handleSubmit() {
            // Validar formulário
            if (!this.validateForm()) {
                return;
            }
            
            // Coletar dados do formulário
            const transaction = {
                date: document.getElementById('date').value,
                month: document.getElementById('month').value,
                year: document.getElementById('year').value,
                category: document.getElementById('category').value,
                subcategory: document.getElementById('subcategory').value || '',
                type: document.getElementById('type').value,
                classification: document.getElementById('classification').value,
                value: parseFloat(document.getElementById('value').value),
                note: document.getElementById('note').value || ''
            };
            
            try {
                // Salvar transação
                await this.database.addTransaction(transaction);
                
                // Limpar formulário
                this.resetForm();
                
                // Navegar para a página de transações
                if (window.app && window.app.navigateTo) {
                    window.app.navigateTo('transactions');
                }
                
                // Mostrar mensagem de sucesso
                this.showSuccessMessage('Transação adicionada com sucesso!');
            } catch (error) {
                console.error('Erro ao salvar transação:', error);
                this.showErrorMessage('Erro ao salvar transação: ' + error.message);
            }
        }

        /**
         * Valida os dados do formulário
         * @returns {boolean} - True se válido, False caso contrário
         */
        validateForm() {
            // Verificar campos obrigatórios
            const requiredFields = ['date', 'category', 'type', 'classification', 'value'];
            let isValid = true;
            
            requiredFields.forEach(fieldId => {
                const field = document.getElementById(fieldId);
                if (field && !field.value.trim()) {
                    this.showFieldError(field, 'Este campo é obrigatório');
                    isValid = false;
                } else if (field) {
                    this.clearFieldError(field);
                }
            });
            
            // Validar valor
            const valueField = document.getElementById('value');
            if (valueField && valueField.value) {
                const value = parseFloat(valueField.value);
                if (isNaN(value) || value <= 0) {
                    this.showFieldError(valueField, 'Valor deve ser maior que zero');
                    isValid = false;
                }
            }
            
            // Validar data
            const dateField = document.getElementById('date');
            if (dateField && dateField.value) {
                const date = new Date(dateField.value);
                if (isNaN(date.getTime())) {
                    this.showFieldError(dateField, 'Data inválida');
                    isValid = false;
                }
            }
            
            return isValid;
        }

        /**
         * Exibe mensagem de erro para um campo específico
         * @param {HTMLElement} field - Campo do formulário
         * @param {string} message - Mensagem de erro
         */
        showFieldError(field, message) {
            this.clearFieldError(field);
            
            const errorDiv = document.createElement('div');
            errorDiv.className = 'field-error';
            errorDiv.style.color = 'var(--danger-color)';
            errorDiv.style.fontSize = '0.85rem';
            errorDiv.style.marginTop = '5px';
            errorDiv.textContent = message;
            
            field.parentNode.appendChild(errorDiv);
            field.style.borderColor = 'var(--danger-color)';
        }

        /**
         * Remove mensagem de erro de um campo
         * @param {HTMLElement} field - Campo do formulário
         */
        clearFieldError(field) {
            if (!field || !field.parentNode) return;
            
            const existingError = field.parentNode.querySelector('.field-error');
            if (existingError) {
                existingError.remove();
            }
            field.style.borderColor = '';
        }

        /**
         * Exibe mensagem de sucesso
         * @param {string} message - Mensagem de sucesso
         */
        showSuccessMessage(message) {
            // Criar notificação temporária
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background-color: var(--success-color);
                color: white;
                padding: 15px 20px;
                border-radius: var(--border-radius);
                box-shadow: var(--box-shadow);
                z-index: 1000;
                animation: slideIn 0.3s ease;
            `;
            
            notification.innerHTML = `
                <i class="fas fa-check-circle"></i> ${message}
            `;
            
            document.body.appendChild(notification);
            
            // Remover após 3 segundos
            setTimeout(() => {
                notification.style.animation = 'slideOut 0.3s ease';
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 300);
            }, 3000);
        }

        /**
         * Exibe mensagem de erro
         * @param {string} message - Mensagem de erro
         */
        showErrorMessage(message) {
            // Criar notificação temporária
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background-color: var(--danger-color);
                color: white;
                padding: 15px 20px;
                border-radius: var(--border-radius);
                box-shadow: var(--box-shadow);
                z-index: 1000;
                animation: slideIn 0.3s ease;
            `;
            
            notification.innerHTML = `
                <i class="fas fa-exclamation-circle"></i> ${message}
            `;
            
            document.body.appendChild(notification);
            
            // Remover após 3 segundos
            setTimeout(() => {
                notification.style.animation = 'slideOut 0.3s ease';
                setTimeout(() => {
                    if (notification.parentNode) {
                        notification.parentNode.removeChild(notification);
                    }
                }, 300);
            }, 3000);
        }

        /**
         * Reseta o formulário para o estado inicial
         */
        resetForm() {
            const form = document.getElementById('transactionForm');
            if (!form) return;
            
            form.reset();
            
            // Restaurar data atual
            const dateInput = document.getElementById('date');
            if (dateInput) {
                const today = new Date().toISOString().split('T')[0];
                dateInput.value = today;
                dateInput.dispatchEvent(new Event('change'));
            }
            
            // Limpar erros
            document.querySelectorAll('.field-error').forEach(error => error.remove());
            document.querySelectorAll('input, select, textarea').forEach(field => {
                field.style.borderColor = '';
            });
        }
    }

    // ============================================
    // CLASSE: DashboardController
    // ============================================
    class DashboardController {
        constructor(database) {
            this.database = database;
        }

        /**
         * Atualiza todos os elementos do dashboard
         */
        async updateDashboard() {
            await this.updateCards();
            await this.updateAlerts();
        }

        /**
         * Atualiza os cards com os valores financeiros
         */
        async updateCards() {
            try {
                const totals = await this.database.getFinancialTotals();
                
                // Atualizar cards
                this.updateElement('totalIncome', `R$ ${totals.totalIncome.toFixed(2)}`);
                this.updateElement('totalExpenses', `R$ ${totals.totalExpenses.toFixed(2)}`);
                this.updateElement('currentBalance', `R$ ${totals.currentBalance.toFixed(2)}`);
                this.updateElement('totalInvested', `R$ ${totals.totalInvested.toFixed(2)}`);
                this.updateElement('investmentReturn', `5%`);
                this.updateElement('lastMonthIncome', `R$ ${totals.lastMonthIncome.toFixed(2)}`);
                this.updateElement('lastMonthExpenses', `R$ ${totals.lastMonthExpenses.toFixed(2)}`);
                
                // Colorir saldo (negativo em vermelho)
                const balanceElement = document.getElementById('currentBalance');
                if (balanceElement) {
                    if (totals.currentBalance < 0) {
                        balanceElement.classList.remove('card-positive');
                        balanceElement.classList.add('card-negative');
                    } else {
                        balanceElement.classList.remove('card-negative');
                        balanceElement.classList.add('card-positive');
                    }
                }
            } catch (error) {
                console.error('Erro ao atualizar cards:', error);
            }
        }

        /**
         * Atualiza um elemento específico
         */
        updateElement(id, text) {
            const element = document.getElementById(id);
            if (element) {
                element.textContent = text;
            }
        }

        /**
         * Atualiza os alertas financeiros
         */
        async updateAlerts() {
            try {
                const alerts = await this.database.getFinancialAlerts();
                const container = document.getElementById('alertsContainer');
                
                if (!container) return;
                
                if (alerts.length === 0) {
                    container.innerHTML = '';
                    return;
                }
                
                let html = '';
                alerts.forEach(alert => {
                    html += `
                        <div class="alert ${alert.type === 'danger' ? 'alert-danger' : 'alert-warning'}">
                            <i class="fas fa-exclamation-triangle"></i>
                            <div>
                                <strong>Alerta Financeiro</strong>
                                <p>${alert.message}</p>
                            </div>
                        </div>
                    `;
                });
                
                container.innerHTML = html;
            } catch (error) {
                console.error('Erro ao atualizar alertas:', error);
            }
        }
    }

    // ============================================
    // CLASSE: ChartsController
    // ============================================
    class ChartsController {
        constructor(database) {
            this.database = database;
            this.charts = {
                expenses: null,
                incomeVsExpenses: null,
                balanceEvolution: null
            };
        }

        /**
         * Atualiza todos os gráficos
         */
        async updateAllCharts() {
            try {
                await this.updateExpensesChart();
                await this.updateIncomeVsExpensesChart();
                await this.updateBalanceEvolutionChart();
            } catch (error) {
                console.error('Erro ao atualizar gráficos:', error);
            }
        }

        /**
         * Atualiza o gráfico de despesas por categoria
         */
        async updateExpensesChart() {
            try {
                const expensesByCategory = await this.database.getExpensesByCategory();
                
                // Preparar dados para o gráfico
                const categories = Object.keys(expensesByCategory);
                const values = Object.values(expensesByCategory);
                
                if (categories.length === 0 || values.length === 0) {
                    this.createEmptyChart('expensesChart', 'Nenhuma despesa registrada');
                    return;
                }
                
                // Gerar cores dinâmicas
                const backgroundColors = this.generateColors(categories.length);
                
                // Obter ou criar canvas
                const canvas = document.getElementById('expensesChart');
                if (!canvas) return;
                
                const ctx = canvas.getContext('2d');
                
                // Destruir gráfico existente
                if (this.charts.expenses) {
                    this.charts.expenses.destroy();
                }
                
                // Criar novo gráfico
                this.charts.expenses = new Chart(ctx, {
                    type: 'doughnut',
                    data: {
                        labels: categories,
                        datasets: [{
                            data: values,
                            backgroundColor: backgroundColors,
                            borderWidth: 1
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        plugins: {
                            legend: {
                                position: 'right',
                                labels: {
                                    color: getComputedStyle(document.documentElement).getPropertyValue('--dark-color')
                                }
                            },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        const label = context.label || '';
                                        const value = context.raw || 0;
                                        const total = context.dataset.data.reduce((a, b) => a + b, 0);
                                        const percentage = Math.round((value / total) * 100);
                                        return `${label}: R$ ${value.toFixed(2)} (${percentage}%)`;
                                    }
                                }
                            }
                        }
                    }
                });
            } catch (error) {
                console.error('Erro ao atualizar gráfico de despesas:', error);
            }
        }

        /**
         * Atualiza o gráfico de receita vs despesa
         */
        async updateIncomeVsExpensesChart() {
            try {
                const totals = await this.database.getFinancialTotals();
                
                // Obter ou criar canvas
                const canvas = document.getElementById('incomeVsExpensesChart');
                if (!canvas) return;
                
                const ctx = canvas.getContext('2d');
                
                // Destruir gráfico existente
                if (this.charts.incomeVsExpenses) {
                    this.charts.incomeVsExpenses.destroy();
                }
                
                // Criar novo gráfico
                this.charts.incomeVsExpenses = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels: ['Receitas', 'Despesas', 'Saldo'],
                        datasets: [{
                            label: 'Valores (R$)',
                            data: [totals.totalIncome, totals.totalExpenses, totals.currentBalance],
                            backgroundColor: [
                                'rgba(76, 201, 240, 0.7)',  // Receitas
                                'rgba(247, 37, 133, 0.7)',  // Despesas
                                totals.currentBalance >= 0 ? 
                                    'rgba(76, 201, 240, 0.7)' : 
                                    'rgba(247, 37, 133, 0.7)'  // Saldo
                            ],
                            borderColor: [
                                'rgb(76, 201, 240)',
                                'rgb(247, 37, 133)',
                                totals.currentBalance >= 0 ? 
                                    'rgb(76, 201, 240)' : 
                                    'rgb(247, 37, 133)'
                            ],
                            borderWidth: 1
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                beginAtZero: true,
                                ticks: {
                                    color: getComputedStyle(document.documentElement).getPropertyValue('--dark-color'),
                                    callback: function(value) {
                                        return 'R$ ' + value.toFixed(2);
                                    }
                                },
                                grid: {
                                    color: 'rgba(0, 0, 0, 0.1)'
                                }
                            },
                            x: {
                                ticks: {
                                    color: getComputedStyle(document.documentElement).getPropertyValue('--dark-color')
                                },
                                grid: {
                                    display: false
                                }
                            }
                        },
                        plugins: {
                            legend: {
                                display: false
                            },
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        return `R$ ${context.raw.toFixed(2)}`;
                                    }
                                }
                            }
                        }
                    }
                });
            } catch (error) {
                console.error('Erro ao atualizar gráfico receita vs despesa:', error);
            }
        }

        /**
         * Atualiza o gráfico de evolução do saldo
         */
        async updateBalanceEvolutionChart() {
            try {
                const balanceData = await this.database.getBalanceEvolution();
                
                if (balanceData.length === 0) {
                    this.createEmptyChart('balanceEvolutionChart', 'Nenhum dado disponível');
                    return;
                }
                
                // Preparar dados
                const labels = balanceData.map(item => `${item.month}/${item.year}`);
                const balances = balanceData.map(item => item.balance);
                
                // Obter ou criar canvas
                const canvas = document.getElementById('balanceEvolutionChart');
                if (!canvas) return;
                
                const ctx = canvas.getContext('2d');
                
                // Destruir gráfico existente
                if (this.charts.balanceEvolution) {
                    this.charts.balanceEvolution.destroy();
                }
                
                // Criar novo gráfico
                this.charts.balanceEvolution = new Chart(ctx, {
                    type: 'line',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: 'Saldo (R$)',
                            data: balances,
                            borderColor: 'rgb(76, 201, 240)',
                            backgroundColor: 'rgba(76, 201, 240, 0.1)',
                            borderWidth: 2,
                            fill: true,
                            tension: 0.4
                        }]
                    },
                    options: {
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            y: {
                                ticks: {
                                    color: getComputedStyle(document.documentElement).getPropertyValue('--dark-color'),
                                    callback: function(value) {
                                        return 'R$ ' + value.toFixed(2);
                                    }
                                },
                                grid: {
                                    color: 'rgba(0, 0, 0, 0.1)'
                                }
                            },
                            x: {
                                ticks: {
                                    color: getComputedStyle(document.documentElement).getPropertyValue('--dark-color')
                                },
                                grid: {
                                    display: false
                                }
                            }
                        },
                        plugins: {
                            tooltip: {
                                callbacks: {
                                    label: function(context) {
                                        return `Saldo: R$ ${context.raw.toFixed(2)}`;
                                    }
                                }
                            }
                        }
                    }
                });
            } catch (error) {
                console.error('Erro ao atualizar gráfico de evolução do saldo:', error);
            }
        }

        /**
         * Cria um gráfico vazio com mensagem
         */
        createEmptyChart(canvasId, message) {
            const canvas = document.getElementById(canvasId);
            if (!canvas) return;
            
            const ctx = canvas.getContext('2d');
            
            // Destruir gráfico existente
            if (this.charts[canvasId]) {
                this.charts[canvasId].destroy();
            }
            
            // Criar gráfico vazio
            this.charts[canvasId] = new Chart(ctx, {
                type: 'doughnut',
                data: {
                    labels: [message],
                    datasets: [{
                        data: [1],
                        backgroundColor: ['rgba(200, 200, 200, 0.5)']
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        },
                        tooltip: {
                            enabled: false
                        }
                    }
                }
            });
        }

        /**
         * Gera um array de cores para os gráficos
         * @param {number} count - Número de cores necessárias
         * @returns {Array} - Array de cores
         */
        generateColors(count) {
            const colors = [
                'rgba(247, 37, 133, 0.7)',    // Rosa
                'rgba(76, 201, 240, 0.7)',    // Azul claro
                'rgba(248, 150, 30, 0.7)',    // Laranja
                'rgba(67, 97, 238, 0.7)',     // Azul
                'rgba(58, 12, 163, 0.7)',     // Roxo
                'rgba(45, 212, 191, 0.7)',    // Turquesa
                'rgba(255, 203, 5, 0.7)',     // Amarelo
                'rgba(108, 92, 231, 0.7)',    // Lilás
                'rgba(255, 107, 107, 0.7)'    // Vermelho claro
            ];
            
            // Se precisar de mais cores que as pré-definidas, gerar aleatoriamente
            if (count > colors.length) {
                for (let i = colors.length; i < count; i++) {
                    colors.push(`rgba(${Math.floor(Math.random() * 255)}, ${Math.floor(Math.random() * 255)}, ${Math.floor(Math.random() * 255)}, 0.7)`);
                }
            }
            
            return colors.slice(0, count);
        }
    }

    // ============================================
    // CLASSE: ImportExportService
    // ============================================
    class ImportExportService {
        constructor(database) {
            this.database = database;
        }

        /**
         * Processa importação de arquivos
         */
        async handleImport() {
            const fileInput = document.getElementById('importFile');
            const importType = document.getElementById('importType').value;
            
            if (!fileInput || !fileInput.files.length) {
                this.showImportStatus('Por favor, selecione um arquivo.', 'error');
                return;
            }
            
            const file = fileInput.files[0];
            this.showImportStatus('Processando arquivo...', 'processing');
            
            try {
                let transactions = [];
                
                switch (importType) {
                    case 'csv':
                        transactions = await this.parseCSV(file);
                        break;
                    case 'xlsx':
                        transactions = await this.parseXLSX(file);
                        break;
                    case 'pdf':
                        transactions = await this.parsePDF(file);
                        break;
                    default:
                        throw new Error('Formato de importação não suportado');
                }
                
                // Validar e importar transações
                await this.importTransactions(transactions);
                
                this.showImportStatus(`${transactions.length} transações importadas com sucesso!`, 'success');
                
                // Atualizar interface
                if (window.app) {
                    if (window.app.transactionTable) {
                        await window.app.transactionTable.loadTransactions();
                    }
                    if (window.app.dashboardController) {
                        await window.app.dashboardController.updateDashboard();
                    }
                    if (window.app.chartsController) {
                        await window.app.chartsController.updateAllCharts();
                    }
                }
                
            } catch (error) {
                console.error('Erro na importação:', error);
                this.showImportStatus(`Erro na importação: ${error.message}`, 'error');
            }
        }

        /**
         * Processa exportação de dados
         */
        async handleExport() {
            const format = document.getElementById('exportFormat').value;
            const dateRange = document.getElementById('exportDateRange').value;
            
            try {
                let transactions = await this.database.getAllTransactions();
                
                // Aplicar filtro de data se necessário
                if (dateRange !== 'all') {
                    transactions = this.filterTransactionsByDateRange(transactions, dateRange);
                }
                
                if (transactions.length === 0) {
                    alert('Nenhuma transação encontrada para o período selecionado.');
                    return;
                }
                
                switch (format) {
                    case 'csv':
                        await this.exportToCSV(transactions);
                        break;
                    case 'pdf':
                        await this.exportToPDF(transactions);
                        break;
                }
            } catch (error) {
                console.error('Erro na exportação:', error);
                alert(`Erro na exportação: ${error.message}`);
            }
        }

        /**
         * Parseia um arquivo CSV
         */
        async parseCSV(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                
                reader.onload = (event) => {
                    try {
                        const csvText = event.target.result;
                        const lines = csvText.split('\n');
                        const headers = lines[0].split(',').map(h => h.trim().replace(/"/g, ''));
                        
                        const transactions = [];
                        
                        for (let i = 1; i < lines.length; i++) {
                            if (lines[i].trim() === '') continue;
                            
                            const values = lines[i].split(',').map(v => v.trim().replace(/"/g, ''));
                            const transaction = {};
                            
                            headers.forEach((header, index) => {
                                transaction[header] = values[index] || '';
                            });
                            
                            // Converter valor para número
                            if (transaction.value || transaction.Valor) {
                                const val = transaction.value || transaction.Valor;
                                transaction.value = parseFloat(val) || 0;
                            }
                            
                            // Validar transação básica
                            if ((transaction.date || transaction.Data) && 
                                (transaction.type || transaction.Tipo) && 
                                transaction.value > 0) {
                                transactions.push(transaction);
                            }
                        }
                        
                        resolve(transactions);
                    } catch (error) {
                        reject(error);
                    }
                };
                
                reader.onerror = () => reject(new Error('Erro ao ler arquivo CSV'));
                reader.readAsText(file);
            });
        }

        /**
         * Parseia um arquivo XLSX
         */
        async parseXLSX(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                
                reader.onload = (event) => {
                    try {
                        const data = new Uint8Array(event.target.result);
                        const workbook = XLSX.read(data, { type: 'array' });
                        const sheetName = workbook.SheetNames[0];
                        const worksheet = workbook.Sheets[sheetName];
                        const jsonData = XLSX.utils.sheet_to_json(worksheet);
                        
                        // Converter para formato padrão
                        const transactions = jsonData.map(row => {
                            return {
                                date: row.Data || row.data || row.Date || row.date,
                                category: row.Categoria || row.categoria || row.Category || row.category,
                                subcategory: row.Subcategoria || row.subcategoria || row.Subcategory || row.subcategory,
                                type: row.Tipo || row.tipo || row.Type || row.type,
                                classification: row.Classificacao || row.classificacao || row.Classification || row.classification,
                                value: parseFloat(row.Valor || row.valor || row.Value || row.value) || 0,
                                note: row.Observacao || row.observacao || row.Note || row.note || row.Obs || row.obs,
                                month: row.Mes || row.mes || row.Month || row.month,
                                year: row.Ano || row.ano || row.Year || row.year
                            };
                        }).filter(t => t.date && t.type && t.value > 0);
                        
                        resolve(transactions);
                    } catch (error) {
                        reject(error);
                    }
                };
                
                reader.onerror = () => reject(new Error('Erro ao ler arquivo Excel'));
                reader.readAsArrayBuffer(file);
            });
        }

        /**
         * Parseia um arquivo PDF (implementação básica)
         */
        async parsePDF(file) {
            return new Promise((resolve, reject) => {
                alert('Importação de PDF requer bibliotecas adicionais. Para demonstração, use CSV ou Excel.');
                reject(new Error('Importação de PDF não totalmente implementada'));
            });
        }

        /**
         * Importa transações para o banco de dados
         */
        async importTransactions(transactions) {
            // Validar cada transação
            const validTransactions = transactions.filter(t => 
                (t.date || t.Data) && 
                (t.type || t.Tipo) && 
                (t.value || t.Valor) > 0
            );
            
            if (validTransactions.length === 0) {
                throw new Error('Nenhuma transação válida encontrada no arquivo');
            }
            
            // Importar para o banco
            for (const transaction of validTransactions) {
                await this.database.addTransaction(transaction);
            }
        }

        /**
         * Filtra transações por intervalo de datas
         */
        filterTransactionsByDateRange(transactions, range) {
            const now = new Date();
            let startDate, endDate;
            
            switch (range) {
                case 'month':
                    startDate = new Date(now.getFullYear(), now.getMonth(), 1);
                    endDate = new Date(now.getFullYear(), now.getMonth() + 1, 0);
                    break;
                case 'year':
                    startDate = new Date(now.getFullYear(), 0, 1);
                    endDate = new Date(now.getFullYear(), 11, 31);
                    break;
                case 'custom':
                    const start = document.getElementById('exportStartDate').value;
                    const end = document.getElementById('exportEndDate').value;
                    
                    if (!start || !end) {
                        throw new Error('Por favor, especifique ambas as datas para o período personalizado');
                    }
                    
                    startDate = new Date(start);
                    endDate = new Date(end);
                    break;
                default:
                    return transactions;
            }
            
            return transactions.filter(t => {
                try {
                    const transactionDate = new Date(t.date);
                    return transactionDate >= startDate && transactionDate <= endDate;
                } catch (error) {
                    return false;
                }
            });
        }

        /**
         * Exporta transações para CSV
         */
        async exportToCSV(transactions) {
            // Definir cabeçalhos
            const headers = ['Data', 'Mês', 'Ano', 'Categoria', 'Subcategoria', 'Tipo', 'Classificação', 'Valor', 'Observação'];
            
            // Converter transações para linhas CSV
            const csvRows = [
                headers.join(','),
                ...transactions.map(t => [
                    t.date,
                    t.month,
                    t.year,
                    t.category,
                    t.subcategory || '',
                    t.type,
                    t.classification,
                    t.value.toFixed(2),
                    t.note || ''
                ].map(v => `"${v}"`).join(','))
            ];
            
            // Criar arquivo
            const csvContent = csvRows.join('\n');
            const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
            const url = URL.createObjectURL(blob);
            
            // Criar link de download
            const link = document.createElement('a');
            link.href = url;
            link.download = `financas_${new Date().toISOString().slice(0, 10)}.csv`;
            link.click();
            
            // Limpar URL
            setTimeout(() => URL.revokeObjectURL(url), 100);
        }

        /**
         * Exporta transações para PDF
         */
        async exportToPDF(transactions) {
            // Esta é uma implementação simplificada usando jsPDF
            const { jsPDF } = window.jspdf;
            const doc = new jsPDF();
            
            // Título
            doc.setFontSize(20);
            doc.text('Relatório Financeiro', 20, 20);
            
            // Data de geração
            doc.setFontSize(10);
            doc.text(`Gerado em: ${new Date().toLocaleDateString('pt-BR')}`, 20, 30);
            
            // Resumo
            let totalIncome = 0;
            let totalExpenses = 0;
            
            transactions.forEach(t => {
                if (t.type === 'Receita') {
                    totalIncome += t.value;
                } else {
                    totalExpenses += t.value;
                }
            });
            
            const balance = totalIncome - totalExpenses;
            
            doc.setFontSize(12);
            doc.text('Resumo:', 20, 45);
            doc.text(`Total de Receitas: R$ ${totalIncome.toFixed(2)}`, 30, 55);
            doc.text(`Total de Despesas: R$ ${totalExpenses.toFixed(2)}`, 30, 65);
            doc.text(`Saldo: R$ ${balance.toFixed(2)}`, 30, 75);
            
            // Lista de transações
            doc.setFontSize(14);
            doc.text('Transações:', 20, 90);
            
            // Cabeçalhos da tabela
            doc.setFontSize(10);
            const headers = [['Data', 'Categoria', 'Tipo', 'Valor']];
            const data = transactions.slice(0, 20).map(t => [
                new Date(t.date).toLocaleDateString('pt-BR'),
                t.category,
                t.type,
                `R$ ${t.value.toFixed(2)}`
            ]);
            
            // Adicionar tabela
            doc.autoTable({
                startY: 95,
                head: headers,
                body: data,
                theme: 'striped',
                headStyles: { fillColor: [67, 97, 238] },
                margin: { horizontal: 20 }
            });
            
            // Salvar PDF
            doc.save(`relatorio_financeiro_${new Date().toISOString().slice(0, 10)}.pdf`);
        }

        /**
         * Gera um backup completo do banco de dados
         */
        async generateBackup() {
            try {
                const data = await this.database.exportAllData();
                const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                
                const link = document.createElement('a');
                link.href = url;
                link.download = `backup_financas_${new Date().toISOString().slice(0, 10)}.json`;
                link.click();
                
                setTimeout(() => URL.revokeObjectURL(url), 100);
                
                if (window.app && window.app.closeModal) {
                    window.app.closeModal('backupModal');
                }
            } catch (error) {
                console.error('Erro ao gerar backup:', error);
                alert(`Erro ao gerar backup: ${error.message}`);
            }
        }

        /**
         * Restaura um backup do banco de dados
         */
        async restoreBackup(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                
                reader.onload = async (event) => {
                    try {
                        const data = JSON.parse(event.target.result);
                        
                        // Validar estrutura do backup
                        if (!data.transactions || !Array.isArray(data.transactions)) {
                            throw new Error('Arquivo de backup inválido');
                        }
                        
                        // Confirmar restauração
                        if (!confirm('Esta ação substituirá todos os dados atuais. Deseja continuar?')) {
                            resolve();
                            return;
                        }
                        
                        // Restaurar dados
                        await this.database.importData(data);
                        
                        alert('Backup restaurado com sucesso!');
                        resolve();
                    } catch (error) {
                        reject(error);
                    }
                };
                
                reader.onerror = () => reject(new Error('Erro ao ler arquivo de backup'));
                reader.readAsText(file);
            });
        }

        /**
         * Exibe status da importação
         */
        showImportStatus(message, type) {
            const statusElement = document.getElementById('importStatus');
            if (!statusElement) return;
            
            const color = type === 'success' ? 'var(--success-color)' : 
                         type === 'error' ? 'var(--danger-color)' : 
                         'var(--warning-color)';
            
            const icon = type === 'success' ? 'check-circle' : 
                        type === 'error' ? 'exclamation-circle' : 
                        'sync-alt';
            
            statusElement.innerHTML = `<p style="color: ${color}"><i class="fas fa-${icon}"></i> ${message}</p>`;
        }
    }

    // ============================================
    // CLASSE: ThemeManager
    // ============================================
    class ThemeManager {
        constructor() {
            this.isDarkMode = false;
        }

        /**
         * Inicializa o gerenciador de temas
         */
        init() {
            // Verificar preferência salva
            const savedTheme = localStorage.getItem('theme');
            if (savedTheme === 'dark') {
                this.enableDarkMode();
            } else {
                this.disableDarkMode();
            }
            
            // Configurar botão de alternância
            const themeToggle = document.getElementById('themeToggle');
            if (themeToggle) {
                themeToggle.addEventListener('click', () => this.toggleTheme());
                this.updateToggleButton();
            }
        }

        /**
         * Alterna entre temas claro e escuro
         */
        toggleTheme() {
            if (this.isDarkMode) {
                this.disableDarkMode();
            } else {
                this.enableDarkMode();
            }
            
            this.updateToggleButton();
            
            // Salvar preferência
            localStorage.setItem('theme', this.isDarkMode ? 'dark' : 'light');
        }

        /**
         * Ativa o modo escuro
         */
        enableDarkMode() {
            document.body.classList.add('dark-mode');
            this.isDarkMode = true;
        }

        /**
         * Desativa o modo escuro
         */
        disableDarkMode() {
            document.body.classList.remove('dark-mode');
            this.isDarkMode = false;
        }

        /**
         * Atualiza o texto e ícone do botão de alternância
         */
        updateToggleButton() {
            const themeToggle = document.getElementById('themeToggle');
            if (!themeToggle) return;
            
            const icon = themeToggle.querySelector('i');
            const text = themeToggle.querySelector('span');
            
            if (this.isDarkMode) {
                if (text) text.textContent = 'Modo Claro';
                if (icon) icon.className = 'fas fa-sun';
            } else {
                if (text) text.textContent = 'Modo Escuro';
                if (icon) icon.className = 'fas fa-moon';
            }
        }
    }

    // ============================================
    // INICIALIZAÇÃO DA APLICAÇÃO
    // ============================================

    // Variável global para a instância do AppController
    let app = null;

    // Inicializar a aplicação quando o DOM estiver pronto
    document.addEventListener('DOMContentLoaded', () => {
        try {
            // Criar instância global do controlador
            app = new AppController();
            window.app = app; // Tornar disponível globalmente
            
            // Adicionar animações CSS
            const style = document.createElement('style');
            style.textContent = `
                @keyframes slideIn {
                    from { transform: translateX(100%); opacity: 0; }
                    to { transform: translateX(0); opacity: 1; }
                }
                
                @keyframes slideOut {
                    from { transform: translateX(0); opacity: 1; }
                    to { transform: translateX(100%); opacity: 0; }
                }
                
                .sort-asc::after {
                    content: " ↑";
                    font-size: 0.8em;
                }
                
                .sort-desc::after {
                    content: " ↓";
                    font-size: 0.8em;
                }
                
                .dragging {
                    opacity: 0.5;
                }
                
                /* CORREÇÃO CRÍTICA - Garantir que apenas uma página seja visível */
                .page {
                    display: none;
                }
                
                .page.active {
                    display: block;
                    animation: fadeIn 0.3s ease;
                }
                
                @keyframes fadeIn {
                    from { opacity: 0; }
                    to { opacity: 1; }
                }
            `;
            document.head.appendChild(style);
            
            console.log('Aplicação inicializada com sucesso!');
        } catch (error) {
            console.error('Erro na inicialização da aplicação:', error);
        }
    });
</script>
</body>
</html>